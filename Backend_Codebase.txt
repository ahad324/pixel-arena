/Users/macbook/Desktop/pixel-arena/server/README.md
<DOCUMENT>
# ‚öôÔ∏è Pixel Arena - Server

This directory contains the backend server for the Pixel Arena application. It is built with Node.js, Express, and TypeScript, and it uses Socket.IO to manage real-time, stateful multiplayer game logic.

## ‚ú® Core Functionality

- **WebSocket Handling:** Manages all real-time communication via Socket.IO.
- **State Management:** The `GameService` class holds the in-memory state of all active rooms, players, and game sessions.
- **Game Logic:** Implements the rules, scoring, and state transitions for all available game modes.
- **Room Management:** Handles the creation, joining, and leaving of game rooms.

## üõ†Ô∏è Tech Stack

- **Runtime:** [Node.js](https://nodejs.org/)
- **Framework:** [Express](https://expressjs.com/)
- **Language:** [TypeScript](https://www.typescriptlang.org/)
- **Communication:** [Socket.IO](https://socket.io/)
- **Development:** [ts-node-dev](https://github.com/wclr/ts-node-dev) for live-reloading.

## üìÇ Folder Structure

The `src/` directory is organized as follows:

```
src/
‚îú‚îÄ‚îÄ config/         # Game constants and settings (e.g., grid size, game timers)
‚îú‚îÄ‚îÄ services/       # Core logic services, primarily `gameService.ts` which is the game engine
‚îú‚îÄ‚îÄ sockets/        # Socket.IO event listeners and emitters, connecting client actions to game logic
‚îú‚îÄ‚îÄ types/          # Shared TypeScript type definitions for the server
‚îú‚îÄ‚îÄ utils/          # Utility functions (e.g., `mazeGenerator.ts`)
‚îú‚îÄ‚îÄ app.ts          # Express app configuration (CORS, basic routes)
‚îî‚îÄ‚îÄ index.ts        # Server entry point, initializes the HTTP server and Socket.IO instance
```

## üì° WebSocket API

The server listens for and emits the following primary Socket.IO events:

| Event Name                 | Direction | Description                                                            |
| -------------------------- | --------- | ---------------------------------------------------------------------- |
| `get-available-rooms`    | Client ‚Üí | Asks the server for a list of joinable rooms.                          |
| `available-rooms-update` | Server ‚Üí | Sends the updated list of available rooms to all clients.              |
| `create-room`            | Client ‚Üí | Creates a new game room with the specified host and game mode.         |
| `join-room`              | Client ‚Üí | Allows a player to join an existing room using a room code.            |
| `room-update`            | Server ‚Üí | Sends the complete, updated state of a room to all players within it.  |
| `set-game-mode`          | Client ‚Üí | Allows the host to change the game mode while in the lobby.            |
| `start-game`             | Client ‚Üí | Tells the server to begin the game for the players in a room.          |
| `player-move`            | Client ‚Üí | Sends a player's new position to the server for validation and update. |
| `player-ability`         | Client ‚Üí | Triggers a player's special ability (e.g., sprint, shield).            |
| `leave-room`             | Client ‚Üí | Notifies the server that a player is leaving the room.                 |
| `disconnect`             | (Event)   | Triggered when a player's connection is lost.                          |

## üìú Available Scripts

From within the `server/` directory, you can run the following commands:

- **`npm run dev`**: Starts the server in development mode using `ts-node-dev` for automatic restarts on file changes.
- **`npm run build`**: Compiles the TypeScript code into JavaScript in the `dist/` directory.
- **`npm run start`**: Runs the compiled JavaScript application from the `dist/` directory.

## ‚öôÔ∏è Environment Variables

The server requires a `.env` file for configuration. Create one by copying the example:

```sh
cp .env.example .env
```

**`server/.env`**

```env
# The port the server will run on
PORT=3000

# The URL of the frontend client, required for CORS configuration
FRONTEND_URL=http://localhost:5173
```
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/.gitignore
<DOCUMENT>
node_modules
package-lock.json
.env
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/package.json
<DOCUMENT>
{
  "name": "pixel-arena-backend",
  "version": "1.0.0",
  "description": "Backend server for Pixel Arena.",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "ts-node --transpile-only --require tsconfig-paths/register src/index.ts",
    "dev": "ts-node-dev --respawn --transpile-only --require tsconfig-paths/register src/index.ts"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "socket.io": "^4.7.5"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "ts-node-dev": "^2.0.0",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.4.5"
  }
}
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/.env
<DOCUMENT>
FRONTEND_URL=http://192.168.1.3:5173
PORT=3000
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/tsconfig.json
<DOCUMENT>
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "@services/*": ["src/services/*"],
      "@sockets/*": ["src/sockets/*"],
      "@config/*": ["src/config/*"],
      "@utils/*": ["src/utils/*"],
      "@app-types/*": ["src/types/*"]
    }
  },
  "include": ["src/**/*"]
}
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/app.ts
<DOCUMENT>
import express from 'express';
import cors from 'cors';

const app = express();

app.use(cors());

app.get("/", (req, res) => {
  res.send("Pixel Arena Server is up and running!");
});

export default app;
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/index.ts
<DOCUMENT>
import http from "http";
import { Server } from "socket.io";
import dotenv from "dotenv";
import app from "./app";
import { initializeSockets } from "@sockets/index";

dotenv.config();

const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: process.env.FRONTEND_URL || "http://localhost:5173",
    methods: ["GET", "POST"],
  },
});

initializeSockets(io);

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/types/index.ts
<DOCUMENT>
export enum GameMode {
  TAG = "Tag",
  TERRITORY_CONTROL = "Territory Control",
  MAZE_RACE = "Maze Race",
  INFECTION_ARENA = "Infection Arena",
  TRAP_RUSH = "Trap Rush",
  SPY_AND_DECODE = "Spy & Decode",
  HEIST_PANIC = "Heist Panic",
}

export type TrapType = "slow" | "teleport" | "freeze";

export interface Trap {
  type: TrapType;
  revealed: boolean;
}

export interface PlayerEffect {
  type: "slow" | "frozen";
  expires: number;
}

export interface Player {
  id: string;
  name: string;
  x: number;
  y: number;
  color: string;
  score: number;
  socketId: string;
  isIt: boolean;
  isEliminated: boolean;
  // Infection Arena
  isInfected?: boolean;
  isShielded?: boolean;
  shieldUntil?: number;
  sprintUntil?: number;
  lastShieldTime?: number;
  lastSprintTime?: number;
  // Trap Rush & Heist Panic
  effects?: PlayerEffect[];
  lastMoveTime?: number;
  // Spy & Decode
  isSpy?: boolean;
  guess?: string | null;
}

export interface Tile {
  claimedBy: string | null;
  color: string | null;
}

export interface Spike {
  id: string;
  x: number;
  y: number;
}

export interface Maze {
  grid: number[][]; // 0 for path, 1 for wall
  end: { x: number; y: number };
}

export type GameStatus = "waiting" | "playing" | "finished";

export interface CodePad {
  id: string;
  x: number;
  y: number;
}

export interface GameState {
  status: GameStatus;
  timer: number;
  winner: Player | { name: string } | null;
  tiles?: Tile[][];
  maze?: Maze;
  // Trap Rush
  trapMap?: (Trap | null)[][];
  finishLine?: number;
  // Spy & Decode
  phase?: "signaling" | "guessing" | "reveal";
  codes?: { id: string; value: string }[];
  correctCodeId?: string;
  playerGuesses?: Record<string, string>;
  // Heist Panic
  codePads?: CodePad[];
  correctPadId?: string;
}

export interface Room {
  id: string;
  hostId: string;
  gameMode: GameMode;
  players: Player[];
  gameState: GameState;
}

export interface GameEvent {
  name: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  data?: any;
}
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/sockets/index.ts
<DOCUMENT>
import { Server, Socket } from "socket.io";
import { gameService } from "@services/gameService";
import type { Player, Room, GameMode, GameEvent } from "@app-types/index";

const TICK_RATE = 20; // Ticks per second
const TICK_INTERVAL = 1000 / TICK_RATE;

export const initializeSockets = (io: Server) => {
  const socketPlayerMap = new Map<
    string,
    { playerId: string; roomId: string }
  >();

  const dispatchEvents = (roomId: string, events: GameEvent[]) => {
    events.forEach((event) => {
      io.to(roomId).emit(event.name, event.data);
    });
  };

  const gameLoop = () => {
    const eventsByRoom = gameService.tick();
    eventsByRoom.forEach((events: GameEvent[], roomId: string) => {
      if (events.length > 0) {
        dispatchEvents(roomId, events);
      }
    });
  };

  setInterval(gameLoop, TICK_INTERVAL);

  io.on("connection", (socket: Socket) => {
    console.log("A user connected:", socket.id);

    const notifyAvailableRoomsUpdate = () => {
      io.emit("available-rooms-update", gameService.getAvailableRooms());
    };

    socket.on("get-available-rooms", () => {
      socket.emit("available-rooms-update", gameService.getAvailableRooms());
    });

    socket.on(
      "create-room",
      (
        {
          user,
          gameMode,
        }: { user: Omit<Player, "socketId">; gameMode: GameMode },
        callback: (room: Room) => void
      ) => {
        const player: Player = { ...user, socketId: socket.id };
        const room = gameService.createRoom(player);
        gameService.setGameMode(room.id, gameMode);
        socket.join(room.id);
        socketPlayerMap.set(socket.id, {
          playerId: player.id,
          roomId: room.id,
        });
        callback(room);
        notifyAvailableRoomsUpdate();
        console.log(`Player ${player.name} created and joined room ${room.id}`);
      }
    );

    socket.on(
      "join-room",
      (
        { roomId, user }: { roomId: string; user: Omit<Player, "socketId"> },
        callback: (res: { room: Room | null; error?: string }) => void
      ) => {
        const player: Player = { ...user, socketId: socket.id };
        const room = gameService.joinRoom(roomId, player);
        if (room) {
          socket.join(roomId);
          socketPlayerMap.set(socket.id, {
            playerId: player.id,
            roomId: roomId,
          });
          callback({ room });
          socket
            .to(roomId)
            .emit("player-joined", {
              player: room.players.find((p:Player) => p.id === player.id),
            });
          notifyAvailableRoomsUpdate();
          console.log(`Player ${player.name} joined room ${roomId}`);
        } else {
          callback({ room: null, error: "Room not found or is full." });
        }
      }
    );

    socket.on(
      "set-game-mode",
      ({ roomId, gameMode }: { roomId: string; gameMode: GameMode }) => {
        const events = gameService.setGameMode(roomId, gameMode);
        dispatchEvents(roomId, events);
      }
    );

    socket.on(
      "start-game",
      ({ roomId, playerId }: { roomId: string; playerId: string }) => {
        const { room, events } = gameService.startGame(roomId, playerId);
        if (room) {
          dispatchEvents(roomId, events);
          notifyAvailableRoomsUpdate();
        }
      }
    );

    socket.on(
      "player-move",
      ({
        roomId,
        playerId,
        newPos,
      }: {
        roomId: string;
        playerId: string;
        newPos: { x: number; y: number };
      }) => {
        const events = gameService.updatePlayerPosition(
          roomId,
          playerId,
          newPos
        );
        if (events.length > 0) dispatchEvents(roomId, events);
      }
    );

    socket.on(
      "player-ability",
      ({ roomId, playerId }: { roomId: string; playerId: string }) => {
        const events = gameService.activateAbility(roomId, playerId);
        if (events.length > 0) dispatchEvents(roomId, events);
      }
    );
    
    socket.on(
      "player-heist-guess",
      ({ roomId, playerId, padId }: { roomId: string; playerId: string; padId: string; }) => {
        const events = gameService.submitGuess(roomId, playerId, padId);
        if(events.length > 0) dispatchEvents(roomId, events);
      }
    );

    socket.on(
      "player-guess",
      ({
        roomId,
        playerId,
        guess,
      }: {
        roomId: string;
        playerId: string;
        guess: string;
      }) => {
        const events = gameService.submitGuess(roomId, playerId, guess);
        if (events.length > 0) dispatchEvents(roomId, events);
      }
    );

    const handleLeave = (socketId: string) => {
      const playerInfo = socketPlayerMap.get(socketId);
      if (playerInfo) {
        const { playerId, roomId } = playerInfo;
        const { events, roomWasDeleted, updatedRoom } = gameService.leaveRoom(
          roomId,
          playerId
        );

        socketPlayerMap.delete(socketId);

        if (roomWasDeleted) {
          console.log(`Room ${roomId} was deleted.`);
        } else {
          dispatchEvents(roomId, events);
          console.log(`Player ${playerId} left room ${roomId}`);
        }
        notifyAvailableRoomsUpdate();
      }
    };

    socket.on("leave-room", () => {
      handleLeave(socket.id);
    });

    socket.on("disconnect", () => {
      console.log("A user disconnected:", socket.id);
      handleLeave(socket.id);
    });
  });
};
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/config/constants.ts
<DOCUMENT>
import { GameMode } from "@app-types/index";

export const GRID_SIZE = 20;
export const CELL_SIZE = 32; // in pixels

export const PLAYER_COLORS = [
  "#3B82F6", // blue-500
  "#22C55E", // green-500
  "#EC4899", // pink-500
  "#F97316", // orange-500
  "#8B5CF6", // violet-500
  "#FBBF24", // amber-400
  "#14B8A6", // teal-500
  "#EF4444", // red-500
];

export const INFECTED_COLOR = "#84CC16"; // lime-500

export const GAME_DESCRIPTIONS: Record<string, string> = {
  [GameMode.TAG]:
    "One player is 'It'. Avoid being tagged to score points. If you're tagged, you're It!",
  [GameMode.TERRITORY_CONTROL]:
    "Claim as many tiles as you can by walking over them. Most tiles in 60 seconds wins!",
  [GameMode.MAZE_RACE]:
    "Be the first to navigate the maze from start to finish. Watch out for dead ends!",
  [GameMode.INFECTION_ARENA]:
    "One player is the Virus. Evade infection or spread it. Last clean player standing wins!",
  [GameMode.TRAP_RUSH]:
    "Race to the finish line across a field of hidden traps. Watch your step!",
  [GameMode.SPY_AND_DECODE]:
    "A secret spy knows the code. They must signal it to you. Guess correctly without being caught!",
  [GameMode.HEIST_PANIC]:
    "Find the correct code pad to escape the vault. A wrong guess will stun you!",
};

export const GAME_SETTINGS = {
  [GameMode.TAG]: {
    POINT_INTERVAL: 1000, // ms
    TIME_LIMIT: 60, // seconds
  },
  [GameMode.TERRITORY_CONTROL]: {
    TIME_LIMIT: 60, // seconds
  },
  [GameMode.MAZE_RACE]: {
    // No specific settings needed here for now
  },
  [GameMode.INFECTION_ARENA]: {
    TIME_LIMIT: 60, // seconds
    SPRINT_DURATION: 1500, // ms
    SPRINT_COOLDOWN: 5000, // ms
    SHIELD_DURATION: 2000, // ms
    SHIELD_COOLDOWN: 10000, // ms
  },
  [GameMode.TRAP_RUSH]: {
    TRAP_DENSITY: 0.2, // 20% of tiles are traps
    SLOW_DURATION: 2000, // ms
    FREEZE_DURATION: 2000, // ms
    TELEPORT_DISTANCE: 5, // tiles
  },
  [GameMode.SPY_AND_DECODE]: {
    SIGNAL_TIME: 20, // seconds
    GUESS_TIME: 10, // seconds
    DECOY_CODES: ["ALPHA", "BRAVO", "CHARLIE", "DELTA", "ECHO"],
  },
  [GameMode.HEIST_PANIC]: {
    TIME_LIMIT: 60, // seconds
    NUM_PADS: 5,
    STUN_DURATION: 3000, // ms
  },
};
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/utils/mazeGenerator.ts
<DOCUMENT>
import type { Maze } from '@app-types/index';

export function generateMaze(width: number, height: number): Omit<Maze, 'end'> & { start: {x:number, y:number}, end: {x:number,y:number} } {
  // Ensure width and height are odd
  const w = width % 2 === 0 ? width - 1 : width;
  const h = height % 2 === 0 ? height - 1 : height;

  const grid: number[][] = Array(h)
    .fill(null)
    .map(() => Array(w).fill(1)); // 1 for wall

  const stack: { x: number; y: number }[] = [];
  const start = { x: 1, y: 1 };
  
  stack.push(start);
  grid[start.y][start.x] = 0; // 0 for path

  const shuffle = <T,>(array: T[]): T[] => {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  };

  while (stack.length > 0) {
    const current = stack.pop()!;
    const neighbors = [];

    const directions = [ { x: 0, y: -2 }, { x: 2, y: 0 }, { x: 0, y: 2 }, { x: -2, y: 0 }];

    for (const dir of shuffle(directions)) {
      const nx = current.x + dir.x;
      const ny = current.y + dir.y;

      if (nx > 0 && nx < w - 1 && ny > 0 && ny < h - 1 && grid[ny][nx] === 1) {
        neighbors.push({ nx, ny, dir });
      }
    }
    
    if (neighbors.length > 0) {
      stack.push(current);
      const { nx, ny, dir } = neighbors[0];
      
      grid[ny][nx] = 0;
      grid[current.y + dir.y / 2][current.x + dir.x / 2] = 0;

      stack.push({ x: nx, y: ny });
    }
  }

  // Post-processing: remove some dead ends to create loops and complexity
  const deadEndRemovalRate = 0.35; // Remove 35% of dead ends
  for (let y = 1; y < h - 1; y += 2) {
      for (let x = 1; x < w - 1; x += 2) {
          if (grid[y][x] === 0) {
              let wallCount = 0;
              const walls = [];
              const wallDirs = [ {x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0} ];
              for(const dir of wallDirs) {
                  if (grid[y + dir.y]?.[x + dir.x] === 1) {
                      wallCount++;
                      walls.push(dir);
                  }
              }
              if (wallCount >= 3 && Math.random() < deadEndRemovalRate) {
                  const wallToBreak = walls[Math.floor(Math.random() * walls.length)];
                  grid[y + wallToBreak.y][x + wallToBreak.x] = 0;
              }
          }
      }
  }

  return {
    grid,
    start: { x: 1, y: 1 },
    end: { x: w - 2, y: h - 2 },
  };
}
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/services/gameService/helpers.ts
<DOCUMENT>
import type {
  GameState,
  Trap,
  TrapType,
  Room,
  CodePad,
} from "@app-types/index";
import { GameMode } from "@app-types/index";
import { GRID_SIZE, GAME_SETTINGS } from "@config/constants";
import { generateMaze } from "@utils/mazeGenerator";

export function createInitialGameState(gameMode: GameMode): GameState {
  const baseState: GameState = { status: "waiting", timer: 0, winner: null };
  switch (gameMode) {
    case GameMode.TERRITORY_CONTROL:
      baseState.tiles = Array(GRID_SIZE)
        .fill(null)
        .map(() => Array(GRID_SIZE).fill({ claimedBy: null, color: null }));
      break;
    case GameMode.MAZE_RACE:
      const mazeData = generateMaze(GRID_SIZE, GRID_SIZE);
      baseState.maze = { grid: mazeData.grid, end: { x: 0, y: 0 } };
      break;
    case GameMode.TRAP_RUSH:
      baseState.trapMap = generateTrapMap();
      baseState.finishLine = GRID_SIZE - 1;
      break;
    case GameMode.SPY_AND_DECODE:
      const { DECOY_CODES } = GAME_SETTINGS[GameMode.SPY_AND_DECODE];
      const shuffledCodes = [...DECOY_CODES].sort(() => 0.5 - Math.random());
      const selectedCodes = shuffledCodes.slice(0, 3);
      baseState.codes = selectedCodes.map((value, i) => ({
        id: String.fromCharCode(65 + i),
        value,
      }));
      baseState.correctCodeId =
        baseState.codes[Math.floor(Math.random() * baseState.codes.length)].id;
      baseState.phase = "signaling";
      baseState.playerGuesses = {};
      break;
    case GameMode.HEIST_PANIC:
      const { NUM_PADS } = GAME_SETTINGS[GameMode.HEIST_PANIC];
      const pads: CodePad[] = [];
      const occupiedCoords = new Set<string>();
      while (pads.length < NUM_PADS) {
        const x = Math.floor(Math.random() * GRID_SIZE);
        const y = Math.floor(Math.random() * GRID_SIZE);
        const coordKey = `${x},${y}`;
        if (!occupiedCoords.has(coordKey)) {
          pads.push({ id: crypto.randomUUID(), x, y });
          occupiedCoords.add(coordKey);
        }
      }
      baseState.codePads = pads;
      baseState.correctPadId = pads[Math.floor(Math.random() * pads.length)].id;
      break;
  }
  return baseState;
}

export function calculateTerritoryScores(room: Room): { [id: string]: number } {
  const scores: { [id: string]: number } = {};
  room.gameState.tiles?.flat().forEach((t) => {
    if (t.claimedBy) scores[t.claimedBy] = (scores[t.claimedBy] || 0) + 1;
  });
  console.log(scores);
  return scores;
}

export function calculateDistances(
  grid: number[][],
  startX: number,
  startY: number
): number[][] {
  const distances = Array(grid.length)
    .fill(null)
    .map(() => Array(grid[0].length).fill(-1));
  if (grid[startY]?.[startX] === 1) return distances;
  const queue: { x: number; y: number; dist: number }[] = [];
  distances[startY][startX] = 0;
  queue.push({ x: startX, y: startY, dist: 0 });
  let head = 0;
  while (head < queue.length) {
    const { x, y, dist } = queue[head++]!;
    const directions = [
      { dx: 0, dy: 1 },
      { dx: 0, dy: -1 },
      { dx: 1, dy: 0 },
      { dx: -1, dy: 0 },
    ];
    for (const dir of directions) {
      const nx = x + dir.dx;
      const ny = y + dir.dy;
      if (
        ny >= 0 &&
        ny < grid.length &&
        nx >= 0 &&
        nx < grid[0].length &&
        grid[ny][nx] === 0 &&
        distances[ny][nx] === -1
      ) {
        distances[ny][nx] = dist + 1;
        queue.push({ x: nx, y: ny, dist: dist + 1 });
      }
    }
  }
  return distances;
}

export function generateTrapMap(): (Trap | null)[][] {
  const { TRAP_DENSITY } = GAME_SETTINGS[GameMode.TRAP_RUSH];
  const trapTypes: TrapType[] = ["slow", "teleport", "freeze"];
  const map: (Trap | null)[][] = Array(GRID_SIZE)
    .fill(null)
    .map(() => Array(GRID_SIZE).fill(null));
  for (let y = 1; y < GRID_SIZE - 1; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (Math.random() < TRAP_DENSITY) {
        map[y][x] = {
          type: trapTypes[Math.floor(Math.random() * trapTypes.length)],
          revealed: false,
        };
      }
    }
  }
  return map;
}

export function generateRoomId(): string {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/services/gameService/gameLogic.ts
<DOCUMENT>
import type { Room, Player, GameEvent } from "@app-types/index";
import { GameMode } from "@app-types/index";
import { GRID_SIZE, GAME_SETTINGS } from "@config/constants";
import {
  calculateDistances,
  createInitialGameState,
  calculateTerritoryScores,
} from "./helpers";

export const gameLogic = {
  startGame: (
    rooms: Map<string, Room>,
    roomId: string,
    playerId: string
  ): { room: Room | undefined; events: GameEvent[] } => {
    const room = rooms.get(roomId);
    if (
      !room ||
      room.hostId !== playerId ||
      room.gameState.status !== "waiting"
    )
      return { room: undefined, events: [] };

    room.gameState = createInitialGameState(room.gameMode);
    initializeGameMode(room);

    return { room, events: [{ name: "game-started", data: { room } }] };
  },
};

export function runMoveLogic(room: Room, player: Player): GameEvent[] {
  const events: GameEvent[] = [];
  switch (room.gameMode) {
    case GameMode.TAG:
      if (player.isIt) {
        const taggedPlayer = room.players.find(
          (p) => !p.isIt && p.x === player.x && p.y === player.y
        );
        if (taggedPlayer) {
          player.isIt = false;
          taggedPlayer.isIt = true;
          events.push({
            name: "player-tagged",
            data: { oldIt: player.id, newIt: taggedPlayer.id },
          });
        }
      }
      break;
    case GameMode.TERRITORY_CONTROL:
      if (
        room.gameState.tiles &&
        room.gameState.tiles[player.y][player.x].claimedBy !== player.id
      ) {
        // paint the tile
        room.gameState.tiles[player.y][player.x] = {
          claimedBy: player.id,
          color: player.color,
        };
        events.push({
          name: "tile-claimed",
          data: {
            x: player.x,
            y: player.y,
            playerId: player.id,
            color: player.color,
          },
        });

        // NEW ‚ûú recompute scores and broadcast
        const scores = calculateTerritoryScores(room);
        room.players.forEach((p) => (p.score = scores[p.id] || 0));
        events.push({
          name: "scores-update",
          data: {
            scores: room.players.map((p) => ({ id: p.id, score: p.score })),
          },
        });
      }
      break;
    case GameMode.MAZE_RACE:
      if (
        player.x === room.gameState.maze?.end.x &&
        player.y === room.gameState.maze?.end.y
      ) {
        events.push(...endGame(room, player));
      }
      break;
    case GameMode.INFECTION_ARENA:
      if (player.isInfected) {
        const now = Date.now();
        const caughtPlayer = room.players.find(
          (p) => !p.isInfected && p.x === player.x && p.y === player.y
        );
        if (
          caughtPlayer &&
          !(caughtPlayer.shieldUntil && now < caughtPlayer.shieldUntil)
        ) {
          caughtPlayer.isInfected = true;
          events.push({
            name: "player-infected",
            data: { playerId: caughtPlayer.id },
          });
          if (room.players.filter((p) => !p.isInfected).length === 0) {
            events.push(...endGame(room));
          }
        }
      }
      break;
    case GameMode.TRAP_RUSH:
      if (player.y >= room.gameState.finishLine!) {
        events.push(...endGame(room, player));
        return events;
      }
      const trap = room.gameState.trapMap?.[player.y]?.[player.x];
      if (trap && !trap.revealed) {
        trap.revealed = true;
        events.push({
          name: "trap-triggered",
          data: { x: player.x, y: player.y, type: trap.type },
        });
        const now = Date.now();
        const settings = GAME_SETTINGS[GameMode.TRAP_RUSH];
        if (!player.effects) player.effects = [];

        let effectType: "frozen" | "slow" | "teleport" | null = null;
        let effectDuration = 0;

        switch (trap.type) {
          case "freeze":
            effectDuration = settings.FREEZE_DURATION;
            effectType = "frozen";
            break;
          case "slow":
            effectDuration = settings.SLOW_DURATION;
            effectType = "slow";
            break;
          case "teleport":
            player.y = Math.max(0, player.y - settings.TELEPORT_DISTANCE);
            effectType = "teleport";
            break;
        }
        if (effectType && effectType !== "teleport") {
          const expires = now + effectDuration;
          player.effects.push({
            type: effectType as "frozen" | "slow",
            expires,
          });
          events.push({
            name: "player-effect",
            data: { playerId: player.id, type: effectType, expires },
          });
        } else if (effectType === "teleport") {
          events.push({
            name: "player-moved",
            data: { playerId: player.id, x: player.x, y: player.y },
          });
        }
      }
      break;
  }
  return events;
}

function initializeGameMode(room: Room) {
  room.gameState.status = "playing";
  room.players.forEach((p) => {
    p.score = 0;
    p.isEliminated = false;
    p.isIt = false;
    p.effects = [];
    p.isInfected = false;
    p.isSpy = false;
    p.guess = null;

    if (room.gameMode === GameMode.TRAP_RUSH) {
      p.x = Math.floor(Math.random() * GRID_SIZE);
      p.y = 0;
    } else if (room.gameMode !== GameMode.MAZE_RACE) {
      p.x = Math.floor(Math.random() * GRID_SIZE);
      p.y = Math.floor(Math.random() * GRID_SIZE);
    }
  });

  switch (room.gameMode) {
    case GameMode.TAG:
      room.gameState.timer = GAME_SETTINGS[GameMode.TAG].TIME_LIMIT;
      room.players[Math.floor(Math.random() * room.players.length)].isIt = true;
      break;
    case GameMode.TERRITORY_CONTROL:
      room.gameState.timer =
        GAME_SETTINGS[GameMode.TERRITORY_CONTROL].TIME_LIMIT;
      break;
    case GameMode.MAZE_RACE:
      setupMazeRace(room);
      break;
    case GameMode.INFECTION_ARENA:
      room.players[Math.floor(Math.random() * room.players.length)].isInfected =
        true;
      room.gameState.timer = GAME_SETTINGS[GameMode.INFECTION_ARENA].TIME_LIMIT;
      break;
    case GameMode.SPY_AND_DECODE:
      room.gameState.phase = "signaling";
      room.gameState.timer = GAME_SETTINGS[GameMode.SPY_AND_DECODE].SIGNAL_TIME;
      if (room.players.length > 1) {
        room.players[Math.floor(Math.random() * room.players.length)].isSpy =
          true;
      } else {
        room.players[0].isSpy = true;
      }
      break;
    case GameMode.HEIST_PANIC:
      room.gameState.timer = GAME_SETTINGS[GameMode.HEIST_PANIC].TIME_LIMIT;
      break;
  }
}

function setupMazeRace(room: Room) {
  const maze = room.gameState.maze!;
  let endX = Math.floor(GRID_SIZE / 2);
  let endY = Math.floor(GRID_SIZE / 2);
  while (maze.grid[endY]?.[endX] !== 0) {
    endX = Math.floor(Math.random() * (GRID_SIZE - 2)) + 1;
    endY = Math.floor(Math.random() * (GRID_SIZE - 2)) + 1;
  }
  maze.end = { x: endX, y: endY };
  const distances = calculateDistances(maze.grid, endX, endY);
  let maxDist = 0;
  const farthestCells: { x: number; y: number }[] = [];
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (distances[y]?.[x] > maxDist) {
        maxDist = distances[y][x];
        farthestCells.length = 0;
        farthestCells.push({ x, y });
      } else if (distances[y]?.[x] === maxDist) {
        farthestCells.push({ x, y });
      }
    }
  }
  const shuffledStarts = farthestCells.sort(() => 0.5 - Math.random());
  room.players.forEach((p, index) => {
    const startPos = shuffledStarts[index % shuffledStarts.length];
    if (startPos) {
      p.x = startPos.x;
      p.y = startPos.y;
    } else {
      p.x = 1;
      p.y = 1;
      while (maze.grid[p.y]?.[p.x] === 1) {
        p.x = Math.floor(Math.random() * (GRID_SIZE - 2)) + 1;
        p.y = Math.floor(Math.random() * (GRID_SIZE - 2)) + 1;
      }
    }
  });
}

export function endGame(room: Room, winner: Player | null = null): GameEvent[] {
  room.gameState.status = "finished";

  if (winner) {
    room.gameState.winner = winner;
  } else {
    switch (room.gameMode) {
      case GameMode.TAG:
        if (room.players.length > 0) {
          const tagWinner = room.players.reduce((prev, current) =>
            prev.score > current.score ? prev : current
          );
          room.gameState.winner = tagWinner;
        }
        break;
      case GameMode.TERRITORY_CONTROL: {
        const scores = calculateTerritoryScores(room);
        room.players.forEach((p) => (p.score = scores[p.id] || 0));
        const winnerId = Object.keys(scores).reduce((a, b) =>
          scores[a] > scores[b] ? a : b
        );
        room.gameState.winner =
          room.players.find((p) => p.id === winnerId) || null;
        break;
      }
      case GameMode.INFECTION_ARENA:
        const survivors = room.players.filter((p) => !p.isInfected);
        if (survivors.length === 0) {
          room.gameState.winner = { name: "The Virus" };
        } else {
          room.gameState.winner = { name: "Survivors" };
        }
        break;
      case GameMode.SPY_AND_DECODE:
        room.gameState.phase = "reveal";
        const spy = room.players.find((p) => p.isSpy);
        const correctGuessers = room.players.filter(
          (p) => p.guess === room.gameState.correctCodeId
        );
        correctGuessers.forEach((p) => (p.score += 1));
        if (
          spy &&
          correctGuessers.some((p) => !p.isSpy) &&
          correctGuessers.length < room.players.length / 2
        ) {
          spy.score += 2;
          room.gameState.winner = spy;
        } else if (correctGuessers.length > 0) {
          room.gameState.winner = { name: "The Agents" };
        } else {
          room.gameState.winner = spy || { name: "No one found the code!" };
        }
        break;
      case GameMode.HEIST_PANIC:
        room.gameState.winner = { name: "The Vault" };
        break;
    }
  }

  return [
    {
      name: "game-over",
      data: { winner: room.gameState.winner, players: room.players },
    },
  ];
}
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/services/gameService/playerActions.ts
<DOCUMENT>
import type { Room,  GameEvent } from "@app-types/index";
import { GameMode } from "@app-types/index";
import { GRID_SIZE, GAME_SETTINGS } from "@config/constants";
import { runMoveLogic, endGame } from "./gameLogic";

export const playerActions = {
  updatePlayerPosition: (
    rooms: Map<string, Room>,
    roomId: string,
    playerId: string,
    newPos: { x: number; y: number }
  ): GameEvent[] => {
    const room = rooms.get(roomId);
    const events: GameEvent[] = [];
    if (!room || room.gameState.status !== "playing") return events;

    const player = room.players.find((p) => p.id === playerId);
    if (!player || player.isEliminated) return events;

    const now = Date.now();
    if (player.effects?.some((e) => e.type === "frozen" && e.expires > now))
      return events;

    if (
      newPos.x < 0 ||
      newPos.x >= GRID_SIZE ||
      newPos.y < 0 ||
      newPos.y >= GRID_SIZE
    )
      return events;

    const isSlowed = player.effects?.some(
      (e) => e.type === "slow" && e.expires > now
    );
    const isSprinting =
      player.isInfected && player.sprintUntil && now < player.sprintUntil;
    const moveCooldown = isSprinting ? 50 : isSlowed ? 250 : 100;

    if (player.lastMoveTime && now - player.lastMoveTime < moveCooldown)
      return events;
    player.lastMoveTime = now;

    if (
      room.gameMode === GameMode.MAZE_RACE &&
      room.gameState.maze?.grid[newPos.y]?.[newPos.x] === 1
    )
      return events;

    player.x = newPos.x;
    player.y = newPos.y;
    events.push({
      name: "player-moved",
      data: { playerId, x: player.x, y: player.y },
    });

    events.push(...runMoveLogic(room, player));
    return events;
  },

  activateAbility: (
    rooms: Map<string, Room>,
    roomId: string,
    playerId: string
  ): GameEvent[] => {
    const room = rooms.get(roomId);
    if (!room || room.gameState.status !== "playing") return [];
    const player = room.players.find((p) => p.id === playerId);
    if (!player) return [];

    const now = Date.now();
    if (room.gameMode === GameMode.INFECTION_ARENA) {
      const settings = GAME_SETTINGS[GameMode.INFECTION_ARENA];
      if (player.isInfected) {
        if (
          !player.lastSprintTime ||
          now - player.lastSprintTime > settings.SPRINT_COOLDOWN
        ) {
          player.lastSprintTime = now;
          player.sprintUntil = now + settings.SPRINT_DURATION;
          return [
            {
              name: "ability-activated",
              data: {
                playerId,
                ability: "sprint",
                expires: player.sprintUntil,
              },
            },
          ];
        }
      } else {
        if (
          !player.lastShieldTime ||
          now - player.lastShieldTime > settings.SHIELD_COOLDOWN
        ) {
          player.lastShieldTime = now;
          player.shieldUntil = now + settings.SHIELD_DURATION;
          return [
            {
              name: "ability-activated",
              data: {
                playerId,
                ability: "shield",
                expires: player.shieldUntil,
              },
            },
          ];
        }
      }
    }
    return [];
  },

  submitGuess: (
    rooms: Map<string, Room>,
    roomId: string,
    playerId: string,
    guess: string
  ): GameEvent[] => {
    const room = rooms.get(roomId);
    if (
      !room ||
      room.gameState.status !== "playing" ||
      room.gameMode !== GameMode.SPY_AND_DECODE ||
      room.gameState.phase !== "guessing"
    )
      return [];
    const player = room.players.find((p) => p.id === playerId);
    if (!player || player.guess) return [];

    if (!room.gameState.playerGuesses) room.gameState.playerGuesses = {};
    room.gameState.playerGuesses[playerId] = guess;
    player.guess = guess;
    return [{ name: "player-guessed", data: { playerId, guess } }];
  },
  
  submitHeistGuess: (
    rooms: Map<string, Room>,
    roomId: string,
    playerId: string,
    padId: string
  ): GameEvent[] => {
    const room = rooms.get(roomId);
    if (
      !room ||
      room.gameState.status !== "playing" ||
      room.gameMode !== GameMode.HEIST_PANIC
    )
      return [];

    const player = room.players.find((p) => p.id === playerId);
    if (!player) return [];

    const pad = room.gameState.codePads?.find((p) => p.id === padId);
    if (!pad || player.x !== pad.x || player.y !== pad.y) return [];
    
    // Check if stunned
    const now = Date.now();
    if (player.effects?.some((e) => e.type === "frozen" && e.expires > now)) return [];

    if (pad.id === room.gameState.correctPadId) {
      // Player wins
      return endGame(room, player);
    } else {
      // Player is stunned
      const settings = GAME_SETTINGS[GameMode.HEIST_PANIC];
      if (!player.effects) player.effects = [];

      const expires = now + settings.STUN_DURATION;
      player.effects.push({ type: "frozen", expires });
      
      const events: GameEvent[] = [
        { name: "player-effect", data: { playerId, type: 'frozen', expires }},
        { name: "pad-guessed", data: { padId, correct: false }}
      ];
      return events;
    }
  },
};
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/services/gameService/gameTick.ts
<DOCUMENT>
import type { Room, GameEvent } from "@app-types/index";
import { GameMode } from "@app-types/index";
import { GAME_SETTINGS, GRID_SIZE } from "@config/constants";
import { endGame } from "./gameLogic";
import { calculateTerritoryScores } from "./helpers";

const TICK_INTERVAL = 1000 / 20; // 50ms for a 20Hz tick rate

export const gameTick = {
  tick: (rooms: Map<string, Room>): Map<string, GameEvent[]> => {
    const allEvents = new Map<string, GameEvent[]>();
    const now = Date.now();

    rooms.forEach((room, roomId) => {
      if (room.gameState.status !== "playing") return;

      const roomEvents: GameEvent[] = [];
      const { gameState, gameMode } = room;

      // Update timers
      if (gameState.timer > 0) {
        const oldTimer = Math.ceil(gameState.timer);
        gameState.timer = Math.max(0, gameState.timer - TICK_INTERVAL / 1000);
        const newTimer = Math.ceil(gameState.timer);

        if (newTimer < oldTimer) {
          roomEvents.push({ name: "timer-update", data: { time: newTimer } });

          if (gameMode === GameMode.TAG) {
            let pointsChanged = false;
            room.players.forEach((p) => {
              if (!p.isIt && !p.isEliminated) {
                p.score++;
                pointsChanged = true;
              }
            });
            if (pointsChanged) {
              roomEvents.push({
                name: "scores-update",
                data: {
                  scores: room.players.map((p) => ({
                    id: p.id,
                    score: p.score,
                  })),
                },
              });
            }
          } else if (gameMode === GameMode.TERRITORY_CONTROL) {
            const currentScores = calculateTerritoryScores(room);
            let pointsChanged = false;
            room.players.forEach((p) => {
              const newScore = currentScores[p.id] || 0;
              if (p.score !== newScore) {
                p.score = newScore;
                pointsChanged = true;
              }
            });
            if (pointsChanged) {
              roomEvents.push({
                name: "scores-update",
                data: {
                  scores: room.players.map((p) => ({
                    id: p.id,
                    score: p.score,
                  })),
                },
              });
            }
          }
        }

        if (gameState.timer <= 0) {
          if (
            gameMode === GameMode.SPY_AND_DECODE &&
            gameState.phase === "signaling"
          ) {
            gameState.phase = "guessing";
            gameState.timer = GAME_SETTINGS[GameMode.SPY_AND_DECODE].GUESS_TIME;
            roomEvents.push({
              name: "phase-changed",
              data: { phase: "guessing", timer: gameState.timer },
            });
          } else {
            roomEvents.push(...endGame(room));
          }
        }
      }

      // Game-specific tick logic can be added here if needed in the future

      if (roomEvents.length > 0) {
        allEvents.set(roomId, roomEvents);
      }
    });

    return allEvents;
  },
};
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/services/gameService/index.ts
<DOCUMENT>
export { gameService } from "./gameService";
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/services/gameService/roomManagement.ts
<DOCUMENT>
import type { Room, Player, GameEvent } from "@app-types/index";
import { GameMode } from "@app-types/index";
import { PLAYER_COLORS } from "@config/constants";
import { generateRoomId, createInitialGameState } from "./helpers";

export const roomManagement = {
  createRoom: (rooms: Map<string, Room>, hostPlayer: Player): Room => {
    const roomId = generateRoomId();
    const hostWithColor = {
      ...hostPlayer,
      color: PLAYER_COLORS[0],
      x: 1,
      y: 1,
      score: 0,
    };

    const newRoom: Room = {
      id: roomId,
      hostId: hostPlayer.id,
      gameMode: GameMode.TAG,
      players: [hostWithColor],
      gameState: createInitialGameState(GameMode.TAG),
    };

    rooms.set(roomId, newRoom);
    return newRoom;
  },

  joinRoom: (
    rooms: Map<string, Room>,
    roomId: string,
    player: Player
  ): Room | null => {
    const room = rooms.get(roomId);
    if (!room || room.players.length >= PLAYER_COLORS.length) return null;

    const playerWithDetails = {
      ...player,
      color: PLAYER_COLORS[room.players.length % PLAYER_COLORS.length],
      x: 1,
      y: 1,
      score: 0,
    };

    room.players.push(playerWithDetails);
    return room;
  },

  setGameMode: (
    rooms: Map<string, Room>,
    roomId: string,
    gameMode: GameMode
  ): GameEvent[] => {
    const room = rooms.get(roomId);
    if (!room || room.gameState.status !== "waiting") return [];
    room.gameMode = gameMode;
    // Always create a fresh game state for the new mode
    room.gameState = createInitialGameState(gameMode);
    return [
      {
        name: "game-mode-changed",
        data: { gameMode, gameState: room.gameState },
      },
    ];
  },

  leaveRoom: (
    rooms: Map<string, Room>,
    roomId: string,
    playerId: string
  ): { events: GameEvent[]; roomWasDeleted: boolean; updatedRoom?: Room } => {
    const room = rooms.get(roomId);
    if (!room) return { events: [], roomWasDeleted: true };

    const wasHost = room.hostId === playerId;
    room.players = room.players.filter((p) => p.id !== playerId);

    if (room.players.length === 0) {
      rooms.delete(roomId);
      return { events: [], roomWasDeleted: true };
    }

    const events: GameEvent[] = [{ name: "player-left", data: { playerId } }];
    if (wasHost) {
      room.hostId = room.players[0].id;
      events.push({ name: "host-changed", data: { newHostId: room.hostId } });
    }
    return { events, roomWasDeleted: false, updatedRoom: room };
  },

  getRoom: (rooms: Map<string, Room>, roomId: string): Room | undefined => {
    return rooms.get(roomId);
  },

  getAvailableRooms: (
    rooms: Map<string, Room>
  ): { id: string; gameMode: GameMode; playerCount: number }[] => {
    return Array.from(rooms.values())
      .filter(
        (room) =>
          room.gameState.status === "waiting" &&
          room.players.length < PLAYER_COLORS.length
      )
      .map((room) => ({
        id: room.id,
        gameMode: room.gameMode,
        playerCount: room.players.length,
      }));
  },
};
</DOCUMENT>

/Users/macbook/Desktop/pixel-arena/server/src/services/gameService/gameService.ts
<DOCUMENT>
import type {
  Room,
  Player,
  GameState,
  GameEvent,
  GameMode,
} from "@app-types/index";
import { roomManagement } from "./roomManagement";
import { playerActions } from "./playerActions";
import { gameLogic } from "./gameLogic";
import { gameTick } from "./gameTick";

class GameService {
  private rooms: Map<string, Room> = new Map();

  // Room Management
  public createRoom = (hostPlayer: Player): Room =>
    roomManagement.createRoom(this.rooms, hostPlayer);
  public joinRoom = (roomId: string, player: Player): Room | null =>
    roomManagement.joinRoom(this.rooms, roomId, player);
  public setGameMode = (roomId: string, gameMode: GameMode): GameEvent[] =>
    roomManagement.setGameMode(this.rooms, roomId, gameMode);
  public leaveRoom = (
    roomId: string,
    playerId: string
  ): { events: GameEvent[]; roomWasDeleted: boolean; updatedRoom?: Room } =>
    roomManagement.leaveRoom(this.rooms, roomId, playerId);
  public getRoom = (roomId: string): Room | undefined =>
    roomManagement.getRoom(this.rooms, roomId);
  public getAvailableRooms = (): {
    id: string;
    gameMode: GameMode;
    playerCount: number;
  }[] => roomManagement.getAvailableRooms(this.rooms);

  // Player Actions
  public updatePlayerPosition = (
    roomId: string,
    playerId: string,
    newPos: { x: number; y: number }
  ): GameEvent[] =>
    playerActions.updatePlayerPosition(this.rooms, roomId, playerId, newPos);
  public activateAbility = (roomId: string, playerId: string): GameEvent[] =>
    playerActions.activateAbility(this.rooms, roomId, playerId);
  public submitGuess = (
    roomId: string,
    playerId: string,
    guess: string
  ): GameEvent[] =>
    playerActions.submitGuess(this.rooms, roomId, playerId, guess);
  public submitHeistGuess = (
    roomId: string,
    playerId: string,
    padId: string
  ): GameEvent[] =>
    playerActions.submitHeistGuess(this.rooms, roomId, playerId, padId);

  // Game Logic
  public startGame = (
    roomId: string,
    playerId: string
  ): { room: Room | undefined; events: GameEvent[] } =>
    gameLogic.startGame(this.rooms, roomId, playerId);

  // Game Tick
  public tick = (): Map<string, GameEvent[]> => gameTick.tick(this.rooms);
}

export const gameService = new GameService();
</DOCUMENT>

