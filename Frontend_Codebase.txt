G:/Ahad/pixel-arena/client/.env
<DOCUMENT>
VITE_BACKEND_URL=http://localhost:3000
</DOCUMENT>

G:/Ahad/pixel-arena/client/.gitignore
<DOCUMENT>
node_modules
.env
</DOCUMENT>

G:/Ahad/pixel-arena/client/eslint.config.js
<DOCUMENT>
import js from '@eslint/js';
import globals from 'globals';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsParser from '@typescript-eslint/parser';

export default [
  {
    ignores: ['dist', 'node_modules']
  },
  {
    files: ['**/*.{js,jsx,ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module'
      }
    },
    settings: {
      react: { version: '18.2' }
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
      '@typescript-eslint': tseslint
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      ...tseslint.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true }
      ],
      '@typescript-eslint/no-unused-vars': [
        'error',
        { argsIgnorePattern: '^_' }
      ],
      '@typescript-eslint/no-explicit-any': 'warn',
      '@typescript-eslint/no-unused-expressions': 'error',
      'no-unused-vars': 'off', // Turn off base rule as it can report incorrect errors
      'no-console': 'warn',
      'prefer-const': 'error',
      'no-var': 'error'
    }
  }
];
</DOCUMENT>

G:/Ahad/pixel-arena/client/index.html
<DOCUMENT>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="/logo.svg" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Pixel Arena - Multiplayer Games</title>
    <style>
      html,
      body {
        overscroll-behavior: none;
      }
    </style>
  </head>
  <body class="bg-gray-900 text-white antialiased">
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>
</DOCUMENT>

G:/Ahad/pixel-arena/client/package.json
<DOCUMENT>
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "framer-motion": "^12.23.6",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "socket.io-client": "^4.7.5"
  },
  "devDependencies": {
    "@eslint/js": "^9.31.0",
    "@types/node": "^24.0.13",
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@typescript-eslint/eslint-plugin": "^8.37.0",
    "@typescript-eslint/parser": "^8.37.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.19",
    "eslint": "^9.31.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.3",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.2.2",
    "vite": "^7.0.4"
  }
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/postcss.config.js
<DOCUMENT>
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/README.md
<DOCUMENT>
# üé® Pixel Arena - Client

This directory contains the frontend for the Pixel Arena application, built with React, Vite, and TypeScript. It handles all user interface elements, real-time communication with the server, and rendering of the game state.

## ‚ú® Features

- **Component-Based Architecture:** Built with reusable React components.
- **Real-time Updates:** Uses `socket.io-client` to listen for and display live game updates from the server.
- **Responsive Design:** Styled with Tailwind CSS for a seamless experience on both desktop and mobile.
- **Mobile-First Controls:** Includes a virtual joystick for intuitive gameplay on touch devices.
- **Typed State:** Leverages TypeScript for robust and predictable state management.

## üõ†Ô∏è Tech Stack

- **Framework:** [React](https://reactjs.org/)
- **Language:** [TypeScript](https://www.typescriptlang.org/)
- **Build Tool:** [Vite](https://vitejs.dev/)
- **Styling:** [Tailwind CSS](https://tailwindcss.com/)
- **State Management:** React Context API
- **Communication:** [Socket.IO Client](https://socket.io/docs/v4/client-api/)

## üìÇ Folder Structure

The `src/` directory is organized as follows:

```
src/
‚îú‚îÄ‚îÄ components/     # Reusable React components (e.g., GameBoard, PlayerAvatar, Buttons)
‚îú‚îÄ‚îÄ constants/      # Game constants, descriptions, and settings used on the client
‚îú‚îÄ‚îÄ contexts/       # React Context for global state management (e.g., user, room)
‚îú‚îÄ‚îÄ hooks/          # Custom React hooks (e.g., usePlayerMovement, useDeviceDetection)
‚îú‚îÄ‚îÄ pages/          # Top-level page components (e.g., LoginPage, LobbyPage, GamePage)
‚îú‚îÄ‚îÄ services/       # Service singletons, like the `socketService` wrapper
‚îú‚îÄ‚îÄ types/          # Shared TypeScript type definitions for the client
‚îú‚îÄ‚îÄ App.tsx         # Main application component, handles routing logic
‚îî‚îÄ‚îÄ index.tsx       # Entry point for the React application
```

## üìú Available Scripts

From within the `client/` directory, you can run the following commands:

- **`npm run dev`**: Starts the Vite development server on `http://localhost:5173`.
- **`npm run build`**: Bundles the application for production into the `dist/` directory.
- **`npm run lint`**: Lints the codebase using ESLint to enforce code quality.
- **`npm run preview`**: Serves the production build locally to test the final output.

## ‚öôÔ∏è Environment Variables

The client requires a `.env` file to know the location of the backend server. Create one by copying the example:

```sh
cp .env.example .env
```

**`client/.env`**

```env
# The URL where the backend server is running
VITE_BACKEND_URL=http://localhost:3000
```
</DOCUMENT>

G:/Ahad/pixel-arena/client/tailwind.config.js
<DOCUMENT>
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        background: '#0D1117',
        surface: {
          100: '#161B22',
          200: '#21262D',
        },
        primary: {
          DEFAULT: '#58A6FF',
          hover: '#80B9FF',
        },
        accent: {
          DEFAULT: '#3FB950',
          hover: '#51C663',
          secondary: '#F778BA',
        },
        error: {
          DEFAULT: '#F85149',
          hover: '#FF6A62',
        },
        text: {
          primary: '#C9D1D9',
          secondary: '#8B949E',
        },
        border: '#30363D',
        warning: '#F0A500',
      },
      animation: {
        'fade-in': 'fadeIn 0.3s ease-out',
        'fade-out': 'fadeOut 0.2s ease-in',
        'slide-up': 'slideUp 0.3s ease-out',
        'slide-down': 'slideDown 0.3s ease-out',
        'scale-in': 'scaleIn 0.2s ease-out',
        'bounce-subtle': 'bounceSubtle 0.4s ease-out',
        'glow-soft': 'glowSoft 2s ease-in-out infinite',
        'shimmer': 'shimmer 1.5s linear infinite',
        'shake': 'shake 0.3s ease-in-out',
        'success-pop': 'successPop 0.4s ease-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        fadeOut: {
          '0%': { opacity: '1' },
          '100%': { opacity: '0' },
        },
        slideUp: {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        slideDown: {
          '0%': { transform: 'translateY(-10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' },
        },
        scaleIn: {
          '0%': { transform: 'scale(0.95)', opacity: '0' },
          '100%': { transform: 'scale(1)', opacity: '1' },
        },
        bounceSubtle: {
          '0%': { transform: 'scale(0.95)' },
          '50%': { transform: 'scale(1.02)' },
          '100%': { transform: 'scale(1)' },
        },
        glowSoft: {
          '0%, 100%': { boxShadow: '0 0 5px currentColor' },
          '50%': { boxShadow: '0 0 15px currentColor' },
        },
        shimmer: {
          '0%': { backgroundPosition: '-200% 0' },
          '100%': { backgroundPosition: '200% 0' },
        },
        shake: {
          '0%, 100%': { transform: 'translateX(0)' },
          '25%': { transform: 'translateX(-3px)' },
          '75%': { transform: 'translateX(3px)' },
        },
        successPop: {
          '0%': { transform: 'scale(0.8)', opacity: '0' },
          '50%': { transform: 'scale(1.05)', opacity: '1' },
          '100%': { transform: 'scale(1)', opacity: '1' },
        },
      },
      transitionProperty: {
        'width': 'width',
        'height': 'height',
        'spacing': 'margin, padding',
        'colors': 'color, background-color, border-color, text-decoration-color, fill, stroke',
        'shadow': 'box-shadow',
        'filter': 'filter',
      },
      transitionTimingFunction: {
        'smooth': 'cubic-bezier(0.4, 0, 0.2, 1)',
        'bounce': 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',
      },
    },
  },
  plugins: [],
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/tsconfig.json
<DOCUMENT>
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": ["vite/client"],
    "baseUrl": ".",
    "paths": {
      "@components/*": ["src/components/*"],
      "@pages/*": ["src/pages/*"],
      "@hooks/*": ["src/hooks/*"],
      "@services/*": ["src/services/*"],
      "@contexts/*": ["src/contexts/*"],
      "@constants/*": ["src/constants/*"],
      "@types/*": ["src/types/*"],
      "@utils/*": ["src/utils/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/tsconfig.node.json
<DOCUMENT>
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/vite.config.ts
<DOCUMENT>
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@components": path.resolve(__dirname, "src/components"),
      "@pages": path.resolve(__dirname, "src/pages"),
      "@hooks": path.resolve(__dirname, "src/hooks"),
      "@services": path.resolve(__dirname, "src/services"),
      "@contexts": path.resolve(__dirname, "src/contexts"),
      "@constants": path.resolve(__dirname, "src/constants"),
      "@utils": path.resolve(__dirname, "src/utils"),
      "@types": path.resolve(__dirname, "src/types"),
    },
  },
  server: {
    host: true,
    // allowedHosts: [".ngrok-free.app"],
  },
});
</DOCUMENT>

G:/Ahad/pixel-arena/client/dist/index.html
<DOCUMENT>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="/logo.svg" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Pixel Arena - Multiplayer Games</title>
    <style>
      html,
      body {
        overscroll-behavior: none;
      }
    </style>
    <script type="module" crossorigin src="/assets/index-Cl0HuQ8d.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-BJzJEbRw.css">
  </head>
  <body class="bg-gray-900 text-white antialiased">
    <div id="root"></div>
  </body>
</html>
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/App.tsx
<DOCUMENT>
import React from "react";
import { motion, AnimatePresence } from "framer-motion";
import GameProvider, { useGame } from "@contexts/GameContext";
import LoginPage from "@pages/LoginPage";
import LobbyPage from "@pages/LobbyPage";
import GamePage from "@pages/GamePage";
import LoadingScreen from "@components/LoadingScreen";

// Page transition variants
const pageVariants = {
  initial: {
    opacity: 0,
    scale: 0.95,
    y: 10,
  },
  in: {
    opacity: 1,
    scale: 1,
    y: 0,
  },
  out: {
    opacity: 0,
    scale: 0.95,
    y: -10,
  },
};

const pageTransition = {
  type: "tween" as const,
  ease: "anticipate" as const,
  duration: 0.2,
};

const AppContent: React.FC = () => {
  const { user, room, isLoading } = useGame();

  const getPageKey = () => {
    if (isLoading) return "loading";
    if (!user) return "login";
    if (!room) return "lobby";
    return "game";
  };

  const renderContent = () => {
    if (isLoading) {
      return <LoadingScreen />;
    }
    if (!user) {
      return <LoginPage />;
    }
    if (!room) {
      return <LobbyPage />;
    }
    return <GamePage />;
  };

  return (
    <main className="bg-background flex flex-col items-center justify-center p-4 font-mono w-full min-h-screen">
      <div className="w-full max-w-7xl mx-auto">
        <AnimatePresence mode="wait">
          <motion.div
            key={getPageKey()}
            initial="initial"
            animate="in"
            exit="out"
            variants={pageVariants}
            transition={pageTransition}
          >
            {renderContent()}
          </motion.div>
        </AnimatePresence>
      </div>
    </main>
  );
};

const App: React.FC = () => {
  return (
    <GameProvider>
      <AppContent />
    </GameProvider>
  );
};

export default App;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/env.d.ts
<DOCUMENT>
interface ImportMetaEnv {
  readonly VITE_BACKEND_URL: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/index.css
<DOCUMENT>
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom scrollbar styles */
.scrollbar-thin::-webkit-scrollbar {
  width: 8px;
}

.scrollbar-thin::-webkit-scrollbar-track {
  background: #161B22; /* surface-200 */
}

.scrollbar-thin::-webkit-scrollbar-thumb {
  background: #30363D; /* border */
  border-radius: 4px;
}

.scrollbar-thin::-webkit-scrollbar-thumb:hover {
  background: #58A6FF; /* primary */
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/index.tsx
<DOCUMENT>
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/EndScreen.tsx
<DOCUMENT>
import React from "react";
import type { Room } from "../types";
import { GameMode } from "../types";
import { TrophyIcon } from "./icons";

interface EndScreenProps {
  room: Room;
  onBackToLobby: () => void;
}

const EndScreen: React.FC<EndScreenProps> = ({ room, onBackToLobby }) => {
  const { winner } = room.gameState;
  const showScores =
    room.gameMode === GameMode.TAG ||
    room.gameMode === GameMode.TERRITORY_CONTROL ||
    room.gameMode === GameMode.SPY_AND_DECODE;

  let sortedPlayers = [...room.players];
  if (room.gameMode === GameMode.TRAP_RUSH && winner && "id" in winner) {
    sortedPlayers = [
      room.players.find((p) => p.id === winner.id)!,
      ...room.players
        .filter((p) => p.id !== winner.id)
        .sort((a, b) => a.id.localeCompare(b.id)),
    ];
  } else {
    sortedPlayers = [...room.players].sort((a, b) => b.score - a.score);
  }

  const winnerName = winner && "name" in winner ? winner.name : "Game Over!";

  return (
    <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
      <div className="bg-surface-100 border border-border rounded-lg p-8 shadow-2xl shadow-primary/20 max-w-lg w-full text-center transform animate-scale-in">
        <TrophyIcon className="h-20 w-20 text-yellow-400 mx-auto mb-4 animate-bounce-subtle" />
        <h1 className="text-4xl font-bold mb-2 animate-slide-up text-text-primary">{winnerName}</h1>
        <p className="text-text-secondary mb-6 animate-fade-in">Results for {room.gameMode}</p>
        <div className="space-y-3 text-left max-h-60 overflow-y-auto pr-2">
          {sortedPlayers.map((player, index) => (
            <div
              key={player.id}
              className="bg-surface-200 p-3 rounded-lg flex justify-between items-center transition-all duration-200 hover:bg-border animate-slide-up"
              style={{ animationDelay: `${index * 0.1}s` }}
            >
              <div className="flex items-center">
                <span className="font-bold text-lg mr-4 text-text-secondary">
                  #{index + 1}
                </span>
                <div
                  className="w-5 h-5 rounded-full mr-3"
                  style={{ backgroundColor: player.color }}
                ></div>
                <span className="font-semibold text-lg text-text-primary">{player.name}</span>
              </div>
              {showScores && (
                <div className="font-bold text-xl text-primary">
                  {player.score} pts
                </div>
              )}
            </div>
          ))}
        </div>
        <button
          onClick={onBackToLobby}
          className="mt-8 w-full bg-primary hover:bg-primary-hover text-white font-bold py-3 px-4 rounded-md focus:outline-none focus:shadow-outline transform hover:scale-105 transition-all duration-200 animate-slide-up"
        >
          Back to Lobby
        </button>
      </div>
    </div>
  );
};

export default EndScreen;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/GameBoard.tsx
<DOCUMENT>
import React, { useState, useRef, useEffect, useMemo } from "react";
import type { Player, Room } from "../types";
import { GameMode, MazeRaceDifficulty } from "../types";
import { GRID_SIZE } from "@constants/index";
import PlayerAvatar from "@components/PlayerAvatar";
import { FreezeIcon, SlowIcon, TeleportIcon } from "@components/icons";

interface GameBoardProps {
  room: Room;
  user: Omit<Player, "socketId"> | null;
  heistPadFeedback?: { [padId: string]: "correct" | "incorrect" };
}

/**
 * A temporary, illusory avatar to confuse players in the Maze Race.
 * It is counter-rotated to appear upright while the maze spins.
 */
const GhostAvatar: React.FC<{
  x: number;
  y: number;
  cellSize: number;
  rotation: number;
}> = ({ x, y, cellSize, rotation }) => (
  <div
    className="absolute transition-transform duration-1000 ease-in-out pointer-events-none animate-in fade-in animate-out fade-out-50"
    style={{
      left: x * cellSize,
      top: y * cellSize,
      width: cellSize,
      height: cellSize,
      transform: `rotate(${rotation}deg)`,
    }}
  >
    <div className="w-full h-full p-[10%]">
      <div className="w-full h-full rounded-full bg-slate-500 opacity-40 blur-sm"></div>
    </div>
  </div>
);

const GameBoard: React.FC<GameBoardProps> = ({
  room,
  user,
  heistPadFeedback,
}) => {
  const { players, gameState, gameMode } = room;
  const containerRef = useRef<HTMLDivElement>(null);
  const [cellSize, setCellSize] = useState(32);
  const [ghosts, setGhosts] = useState<{ x: number; y: number; id: string }[]>(
    []
  );
  const [clientRotation, setClientRotation] = useState(0);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const updateSize = () => {
      const { offsetWidth, offsetHeight } = container;
      const minDimension = Math.min(offsetWidth, offsetHeight);
      const newCellSize = Math.max(1, Math.floor(minDimension / GRID_SIZE));
      setCellSize(newCellSize);
    };

    const resizeObserver = new ResizeObserver(updateSize);
    resizeObserver.observe(container);
    updateSize(); // Initial size check
    return () => resizeObserver.disconnect();
  }, []);

  // Effect to make the maze randomly rotate based on difficulty
  useEffect(() => {
    if (gameMode !== GameMode.MAZE_RACE || gameState.status !== "playing") {
      if (clientRotation !== 0) {
        setClientRotation(0);
      }
      return;
    }

    const difficulty = gameState.maze?.difficulty || MazeRaceDifficulty.EASY;
    const shouldRotate = difficulty === MazeRaceDifficulty.HARD || difficulty === MazeRaceDifficulty.EXPERT;
    
    if (!shouldRotate) {
      if (clientRotation !== 0) {
        setClientRotation(0);
      }
      return;
    }

    const rotationInterval = setInterval(() => {
      setClientRotation((prev) => (prev + 90) % 360);
    }, 12000); // Rotate every 12 seconds

    return () => {
      clearInterval(rotationInterval);
    };
  }, [gameMode, gameState.status, gameState.maze?.difficulty, clientRotation]);

  // Effect to spawn and despawn ghosts in Maze Race based on difficulty
  useEffect(() => {
    if (
      gameMode !== GameMode.MAZE_RACE ||
      gameState.status !== "playing" ||
      !gameState.maze
    ) {
      setGhosts([]);
      return;
    }

    const difficulty = gameState.maze?.difficulty || MazeRaceDifficulty.EASY;
    const shouldShowGhosts = difficulty === MazeRaceDifficulty.EXPERT;
    
    if (!shouldShowGhosts) {
      setGhosts([]);
      return;
    }

    const emptyCells: { x: number; y: number }[] = [];
    gameState.maze.grid.forEach((row, y) => {
      row.forEach((cell, x) => {
        if (cell === 0) {
          emptyCells.push({ x, y });
        }
      });
    });

    const ghostInterval = setInterval(() => {
      if (emptyCells.length > 0) {
        const randomIndex = Math.floor(Math.random() * emptyCells.length);
        const { x, y } = emptyCells[randomIndex];
        const newGhost = { x, y, id: crypto.randomUUID() };

        setGhosts((prev) => [...prev, newGhost]);

        // Ghosts last for 2-4 seconds
        setTimeout(() => {
          setGhosts((prev) => prev.filter((g) => g.id !== newGhost.id));
        }, 2000 + Math.random() * 2000);
      }
    }, 4000 + Math.random() * 3000); // New ghost every 4-7 seconds

    return () => {
      clearInterval(ghostInterval);
    };
  }, [gameMode, gameState.status, gameState.maze]);

  const boardSize = GRID_SIZE * cellSize;

  const fogOfWarOverlayStyle = useMemo(() => {
    if (
      gameMode !== GameMode.MAZE_RACE ||
      gameState.status !== "playing" ||
      !user
    ) {
      return null;
    }

    const difficulty = gameState.maze?.difficulty || MazeRaceDifficulty.EASY;
    const shouldShowFog = difficulty === MazeRaceDifficulty.MEDIUM || difficulty === MazeRaceDifficulty.EXPERT;
    
    if (!shouldShowFog) {
      return null;
    }

    const currentPlayer = players.find((p) => p.id === user.id);
    if (!currentPlayer) {
      return { background: "rgba(13, 17, 23, 0.98)" }; // background color
    }

    const visibilityInCells = 4.5;
    const visibilityRadiusPx = visibilityInCells * cellSize;
    const playerCenterX = currentPlayer.x * cellSize + cellSize / 2;
    const playerCenterY = currentPlayer.y * cellSize + cellSize / 2;

    const gradient = `radial-gradient(circle ${visibilityRadiusPx}px at ${playerCenterX}px ${playerCenterY}px, transparent 0%, transparent 70%, rgba(13, 17, 23, 0.98) 100%)`;

    return {
      background: gradient,
    };
  }, [gameMode, gameState.status, gameState.maze?.difficulty, players, user, cellSize]);

  const renderGameSpecificElements = () => {
    switch (gameMode) {
      case GameMode.TERRITORY_CONTROL:
        return gameState.tiles?.flat().map((tile, index) =>
          tile.color ? (
            <div
              key={index}
              className="absolute transition-colors duration-500"
              style={{
                left: `${(index % GRID_SIZE) * cellSize}px`,
                top: `${Math.floor(index / GRID_SIZE) * cellSize}px`,
                width: cellSize,
                height: cellSize,
                backgroundColor: tile.color,
                opacity: 0.4,
              }}
            ></div>
          ) : null
        );
      case GameMode.MAZE_RACE:
        return gameState.maze?.grid.map((row, y) =>
          row.map((cell, x) =>
            cell === 1 ? (
              <div
                key={`${x}-${y}`}
                className="absolute bg-surface-200 border border-border"
                style={{
                  left: x * cellSize,
                  top: y * cellSize,
                  width: cellSize,
                  height: cellSize,
                }}
              ></div>
            ) : gameState.maze?.end &&
              y === gameState.maze.end.y &&
              x === gameState.maze.end.x ? (
              <div
                key="end-point"
                className="absolute bg-accent/50 rounded-full animate-pulse"
                style={{
                  left: x * cellSize + cellSize / 4,
                  top: y * cellSize + cellSize / 4,
                  width: cellSize / 2,
                  height: cellSize / 2,
                }}
              ></div>
            ) : null
          )
        );
      case GameMode.HEIST_PANIC:
        return gameState.codePads?.map((pad) => {
          const feedback = heistPadFeedback?.[pad.id];
          let feedbackClass =
            "bg-warning/20 border-warning animate-pulse";
          let feedbackContent = "?";

          if (feedback === "incorrect") {
            feedbackClass = "bg-error/50 border-error animate-pulse";
            feedbackContent = "X";
          } else if (feedback === "correct") {
            feedbackClass = "bg-accent/50 border-accent animate-pulse";
            feedbackContent = "‚úì";
          }

          return (
            <div
              key={pad.id}
              className="absolute"
              style={{
                left: pad.x * cellSize,
                top: pad.y * cellSize,
                width: cellSize,
                height: cellSize,
              }}
            >
              <div
                className={`w-full h-full border-2 rounded-md flex items-center justify-center font-bold transition-all duration-300 ${feedbackClass}`}
              >
                {feedbackContent}
              </div>
            </div>
          );
        });
      case GameMode.TRAP_RUSH: {
        const trapElements = gameState.trapMap?.flatMap((row, y) =>
          row.map((trap, x) => {
            if (!trap || !trap.revealed) return null;
            const trapIcons = {
              freeze: <FreezeIcon className="w-full h-full text-cyan-400" />,
              slow: <SlowIcon className="w-full h-full text-orange-400" />,
              teleport: (
                <TeleportIcon className="w-full h-full text-purple-400" />
              ),
            };
            return (
              <div
                key={`${x}-${y}`}
                className="absolute p-2"
                style={{
                  left: x * cellSize,
                  top: y * cellSize,
                  width: cellSize,
                  height: cellSize,
                }}
              >
                <div className="w-full h-full bg-surface-100/50 rounded-full animate-in fade-in">
                  {trapIcons[trap.type]}
                </div>
              </div>
            );
          })
        );
        const finishLine = (
          <div
            key="finish-line"
            className="absolute"
            style={{
              left: 0,
              top: gameState.finishLine! * cellSize,
              width: "100%",
              height: cellSize,
              backgroundImage:
                "repeating-conic-gradient(#161B22 0% 25%, #30363D 0% 50%)",
              backgroundSize: `${cellSize}px ${cellSize}px`,
              opacity: 0.8,
            }}
          ></div>
        );
        return [finishLine, ...(trapElements || [])];
      }
      default:
        return null;
    }
  };

  return (
    <div
      ref={containerRef}
      className="w-full h-full flex items-center justify-center"
    >
      <div
        className="relative bg-background border-2 border-border rounded-lg overflow-hidden flex-shrink-0"
        style={{
          width: boardSize,
          height: boardSize,
          backgroundImage:
            "linear-gradient(rgba(201, 209, 217, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(201, 209, 217, 0.05) 1px, transparent 1px)",
          backgroundSize: `${cellSize}px ${cellSize}px`,
          transform: `rotate(${clientRotation}deg)`,
          transition: "transform 1s ease-in-out",
        }}
      >
        {renderGameSpecificElements()}
        {players.map((player) => (
          <PlayerAvatar key={player.id} player={player} cellSize={cellSize} />
        ))}
        {ghosts.map((g) => (
          <GhostAvatar
            key={g.id}
            x={g.x}
            y={g.y}
            cellSize={cellSize}
            rotation={-clientRotation}
          />
        ))}
        {fogOfWarOverlayStyle && (
          <div
            className="absolute inset-0 pointer-events-none transition-all duration-300 ease-linear"
            style={fogOfWarOverlayStyle}
          ></div>
        )}
      </div>
    </div>
  );
};

export default GameBoard;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/GameControls.tsx
<DOCUMENT>
import React from "react";
import type { Room } from "../types/index";

const GameControls: React.FC<{
  room: Room;
  isHost: boolean;
  onStartGame: () => void;
  onLeaveRoom: () => void;
}> = ({ room, isHost, onStartGame, onLeaveRoom }) => {
  return (
    <>
      {room.gameState.status === "waiting" && isHost && (
        <button
          onClick={onStartGame}
          disabled={room.players.length < 1}
          className="w-full bg-accent hover:bg-accent-hover text-white font-bold py-3 px-4 rounded-md focus:outline-none focus:shadow-outline transition-all duration-200 disabled:bg-surface-200 disabled:text-text-secondary disabled:cursor-not-allowed mt-2 transform hover:scale-105 disabled:hover:scale-100"
        >
          Start Game
        </button>
      )}
      <button
        onClick={onLeaveRoom}
        className="w-full mt-2 bg-error/80 hover:bg-error text-white font-bold py-2 px-4 rounded-md focus:outline-none focus:shadow-outline transition-all duration-200 transform hover:scale-105"
      >
        Leave Room
      </button>
    </>
  );
};

export default GameControls;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/GameStatus.tsx
<DOCUMENT>
import React from "react";
import type { Room } from "../types";
import { GameMode } from "../types";

const GameStatus: React.FC<{ room: Room; isFullscreen: boolean }> = ({ room, isFullscreen }) => {
  const getStatusMessage = () => {
    const { status, timer, phase } = room.gameState;
    const { gameMode } = room;

    if (status === "waiting") return "Waiting for host to start...";
    if (timer > 0)
      return `${phase
          ? `${phase.charAt(0).toUpperCase() + phase.slice(1)} Phase: `
          : "Time Left: "
        }${timer}s`;

    switch (gameMode) {
      case GameMode.TAG:
        return "Don't get tagged!";
      case GameMode.MAZE_RACE:
        return "First to the finish wins!";
      case GameMode.INFECTION_ARENA:
        return "Don't get infected!";
      case GameMode.TRAP_RUSH:
        return "Get to the finish line!";
      case GameMode.SPY_AND_DECODE:
        return "Awaiting next phase...";
      case GameMode.HEIST_PANIC:
        return "First to the correct code wins!";
      default:
        return "";
    }
  };

  const statusMessage = getStatusMessage();

  return isFullscreen ? (
    <div className="absolute top-4 left-1/2 -translate-x-1/2 bg-black/50 backdrop-blur-sm text-text-primary font-bold text-lg md:text-2xl px-4 py-2 md:px-6 md:py-3 rounded-xl z-10 pointer-events-none shadow-lg border border-border">
      {statusMessage}
    </div>
  ) : (
    <div className="bg-primary/10 text-primary rounded-md p-3 text-center mb-4 font-semibold border border-primary/20">
      {statusMessage}
    </div>
  );
};

export default GameStatus;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/GameStatusDisplay.tsx
<DOCUMENT>
import React from 'react';
import type { Player, Room } from "../types";
import { GameMode } from "../types";

interface GameStatusDisplayProps {
    room: Room;
    user: Omit<Player, "socketId">;
    className?: string;
}

const getStatusMessage = (room: Room, user: Omit<Player, "socketId">): string => {
    const { status, timer, phase } = room.gameState;
    const { gameMode } = room;
    const you = room.players.find((p) => p.id === user.id);

    if (status === "waiting") return "Waiting for host to start...";
    if (timer > 0)
      return `${
        phase
          ? `${phase.charAt(0).toUpperCase() + phase.slice(1)} Phase: `
          : "Time Left: "
      }${timer}s`;

    switch (gameMode) {
      case GameMode.TAG:
        return you?.isIt ? "You are It!" : "Don't get tagged!";
      case GameMode.MAZE_RACE:
        return "First to the finish wins!";
      case GameMode.INFECTION_ARENA:
        return you?.isInfected ? "Infect everyone!" : "Don't get infected!";
      case GameMode.TRAP_RUSH:
        return "Get to the finish line!";
      case GameMode.SPY_AND_DECODE:
        return "Awaiting next phase...";
      default:
        return "";
    }
};


const GameStatusDisplay: React.FC<GameStatusDisplayProps> = ({ room, user, className }) => {
    const message = getStatusMessage(room, user);

    if (!message) {
        return null;
    }

    return (
        <div className={className}>
            {message}
        </div>
    );
};

export default GameStatusDisplay;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/icons.tsx
<DOCUMENT>
import React from "react";

export const LogoIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} viewBox="0 0 24 24" fill="currentColor">
    <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5-10-5-10 5zM2 12l10 5 10-5-10-5-10 5z" />
  </svg>
);

export const TagIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M7 7h.01M7 3h5a2 2 0 012 2v5a2 2 0 01-2 2H7a2 2 0 01-2-2V5a2 2 0 012-2zM11 5h.01M15 3h2a2 2 0 012 2v2M15 11h2a2 2 0 012 2v2M9 15H7a2 2 0 01-2-2v-2M9 21H7a2 2 0 01-2-2v-2"
    />
  </svg>
);

export const TerritoryIcon: React.FC<React.SVGProps<SVGSVGElement>> = (
  props
) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M4 6a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6z"
    />
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M10 4v16m4-16v16M4 10h16M4 14h16"
    />
  </svg>
);

export const MazeIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M9 3v4m6 0V3m-6 4h6M9 7v4m6-4v4m-6 4h6M9 11v4m6-4v4m-6 4h6M9 15v4m6-4v4M4 7h2m-2 4h2m-2 4h2m12-8h2m-2 4h2m-2 4h2M4 3h16"
    />
  </svg>
);

export const HeistIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8V6m0 12v-2" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 18a6 6 0 100-12 6 6 0 000 12z" />
  </svg>
);

export const InfectionIcon: React.FC<React.SVGProps<SVGSVGElement>> = (
  props
) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 15a1 1 0 01-1-1v-4a1 1 0 112 0v4a1 1 0 01-1 1zm-4.24-9.76l1.41 1.41M14.83 6.24l1.41 1.41M12 5a1 1 0 100-2 1 1 0 000 2zm0 14a1 1 0 100-2 1 1 0 000 2zm-7.76-4.24l1.41-1.41M6.24 7.66l1.41-1.41"
    />
  </svg>
);

export const TrapIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
    />
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M4.93 4.93l4.24 4.24M14.83 9.17l4.24-4.24M9.17 14.83l-4.24 4.24M19.07 19.07l-4.24-4.24"
    />
  </svg>
);

export const SpyIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
    />
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
    />
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M15 13l-3 3-3-3"
    />
  </svg>
);

export const CreateIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M12 9v3m0 0v3m0-3h3m-3 0H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"
    />
  </svg>
);

export const EnterIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h5a3 3 0 013 3v1"
    />
  </svg>
);

export const TrophyIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M5 3v4M19 3v4M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2zM9 12a3 3 0 106 0 3 3 0 00-6 0z"
    />
  </svg>
);

export const FreezeIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M5 11l7-7 7 7M5 19l7-7 7 7"
    />
  </svg>
);

export const SlowIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
    />
  </svg>
);

export const TeleportIcon: React.FC<React.SVGProps<SVGSVGElement>> = (
  props
) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M13 10V3L4 14h7v7l9-11h-7z"
    />
  </svg>
);

export const InfoIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
    />
  </svg>
);

export const CheckCircleIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
    />
  </svg>
);

export const StatusNewIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" stroke="currentColor" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24" aria-hidden="true">
    <path d="M12 2 L15 8 L22 9 L17 14 L18 21 L12 18 L6 21 L7 14 L2 9 L9 8 Z" />
  </svg>
);

export const StatusBetaIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" stroke="currentColor" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24" aria-hidden="true">
    <circle cx={12} cy={12} r={10} />
    <path d="M8 8h4a3 3 0 010 6H8" />
    <path d="M8 8v8" />
  </svg>
);

export const StatusPopularIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" stroke="currentColor" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24" aria-hidden="true">
    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
  </svg>
);

export const StatusUpdatedIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" stroke="currentColor" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24" aria-hidden="true">
    <path d="M1 4v6h6" />
    <path d="M3.51 15a9 9 0 102.13-9.36L1 10" />
  </svg>
);

export const StatusFeaturedIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" stroke="currentColor" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24" aria-hidden="true">
    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
    <circle cx="12" cy="12" r="2" />
  </svg>
);

export const StatusExperimentalIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" stroke="currentColor" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24" aria-hidden="true">
    <path d="M9 2v6L7 10l2 2v6a2 2 0 002 2h2a2 2 0 002-2v-6l2-2-2-2V2" />
    <path d="M7 10h10" />
    <circle cx="12" cy="16" r="1" />
  </svg>
);

export const StatusComingSoonIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" stroke="currentColor" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24" aria-hidden="true">
    <circle cx="12" cy="12" r="10" />
    <polyline points="12,6 12,12 16,14" />
  </svg>
);

export const StatusLimitedTimeIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" stroke="currentColor" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24" aria-hidden="true">
    <path d="M12 2L2 7v10c0 5.55 3.84 10 9 11 5.16-1 9-5.45 9-11V7l-10-5z" />
    <polyline points="9,12 12,15 22,4" />
  </svg>
);

export const EnterFullscreenIcon: React.FC<React.SVGProps<SVGSVGElement>> = (
  props
) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M4 8V4h4M20 8V4h-4M4 16v4h4M20 16v4h-4"
    />
  </svg>
);

export const ShareIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg
    {...props}
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <circle cx="18" cy="5" r="3"></circle>
    <circle cx="6" cy="12" r="3"></circle>
    <circle cx="18" cy="19" r="3"></circle>
    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
  </svg>
);

export const AddToHomeScreenIcon: React.FC<React.SVGProps<SVGSVGElement>> = (
  props
) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M12 9v3m0 0v3m0-3h3m-3 0H9"
    />
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M5 3a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V5a2 2 0 00-2-2H5z"
    />
  </svg>
);

export const PowerIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M12 3v9"
    />
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M17.66 6.34a8 8 0 11-11.31 0"
    />
  </svg>
);


export const LogoutIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg {...props} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"
    />
  </svg>
);
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/InstructionsModal.tsx
<DOCUMENT>
import React, { useEffect } from "react";
import { GameMode } from "../types";
import { GAME_INSTRUCTIONS } from "@constants/index";
import { useDeviceDetection } from "@hooks/useDeviceDetection";

interface InstructionsModalProps {
  gameMode: GameMode;
  onClose: () => void;
}

const InstructionsModal: React.FC<InstructionsModalProps> = ({
  gameMode,
  onClose,
}) => {
  const instructions = GAME_INSTRUCTIONS[gameMode];
  const { isMobile } = useDeviceDetection();

  useEffect(() => {
    const handleEsc = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        onClose();
      }
    };
    window.addEventListener("keydown", handleEsc);
    return () => window.removeEventListener("keydown", handleEsc);
  }, [onClose]);

  if (!instructions) {
    return null;
  }

  const controlsToShow = isMobile
    ? instructions.controls.mobile
    : instructions.controls.desktop;

  return (
    <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
      <div
        className={`bg-surface-100 border border-border rounded-lg shadow-2xl shadow-primary/20 w-full max-w-[90vw] sm:max-w-lg md:max-w-xl mx-4 
          ${isMobile ? 'max-h-[80vh]' : 'max-h-[90vh]'} flex flex-col overflow-hidden`}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center p-4 border-b border-border">
          <h2 className="text-2xl font-bold text-text-primary">{instructions.title}</h2>
          <button
            onClick={onClose}
            className="text-text-secondary hover:text-text-primary focus:outline-none transition-colors p-2"
            aria-label="Close Instructions"
          >
            <svg
              className="w-6 h-6"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              strokeWidth={2}
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        </div>
        <div className="p-4 overflow-y-auto scrollbar-thin scrollbar-thumb-border scrollbar-track-surface-200">
          <div className="space-y-4 text-text-primary">
            <div>
              <h3 className="font-bold text-lg text-primary mb-2">Objective</h3>
              <p className="text-text-secondary">{instructions.objective}</p>
            </div>
            <div>
              <h3 className="font-bold text-lg text-primary mb-2">Rules</h3>
              <ul className="list-disc list-inside space-y-1 text-text-secondary">
                {instructions.rules.map((rule, index) => (
                  <li key={index}>{rule}</li>
                ))}
              </ul>
            </div>
            <div>
              <h3 className="font-bold text-lg text-primary mb-2">Controls</h3>
              <ul className="list-disc list-inside space-y-1 text-text-secondary">
                {controlsToShow.map((control, index) => (
                  <li key={index}>{control}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
        <div className="p-4 border-t border-border flex justify-end">
          <button
            onClick={onClose}
            className="bg-primary hover:bg-primary-hover text-white font-bold py-2 px-4 rounded-md focus:outline-none transition-all duration-200 hover:scale-105"
          >
            Got it!
          </button>
        </div>
      </div>
    </div>
  );
};

export default InstructionsModal;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/LoadingScreen.tsx
<DOCUMENT>
import React from 'react';
import Spinner from '@components/Spinner';
import { LogoIcon } from '@components/icons';

const LoadingScreen: React.FC = () => {
    return (
        <div className="w-full h-full flex flex-col items-center justify-center gap-4 animate-fade-in">
            <div className="p-4 bg-surface-100 rounded-full mb-4 border border-border animate-bounce-subtle">
                <LogoIcon className="h-16 w-16 text-primary"/>
            </div>
            <Spinner className="w-16 h-16" />
            <p className="text-text-secondary mt-2 animate-fade-in">Loading Pixel Arena...</p>
        </div>
    );
};

export default LoadingScreen;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/PlayerAvatar.tsx
<DOCUMENT>
import React from "react";
import type { Player } from "../types";
import { INFECTED_COLOR } from "@constants/index";
import { FreezeIcon } from "@components/icons";

interface PlayerAvatarProps {
  player: Player;
  cellSize: number;
}

const PlayerAvatar: React.FC<PlayerAvatarProps> = ({ player, cellSize }) => {
  if (player.isEliminated) {
    return null;
  }

  const now = Date.now();
  const isShielded = player.shieldUntil && now < player.shieldUntil;
  const itClass = player.isIt
    ? "shadow-lg shadow-red-500/80 ring-2 ring-red-400 animate-pulse"
    : "";
  const shieldClass = isShielded
    ? "ring-4 ring-cyan-400 ring-offset-2 ring-offset-background animate-pulse"
    : "";

  const isFrozen = player.effects?.some(
    (e) => e.type === "frozen" && e.expires > now
  );
  const isSlowed = player.effects?.some(
    (e) => e.type === "slow" && e.expires > now
  );

  return (
    <div
      className="absolute transition-all duration-100 ease-linear"
      style={{
        left: player.x * cellSize,
        top: player.y * cellSize,
        width: cellSize,
        height: cellSize,
        filter: `drop-shadow(0 2px 4px ${
          player.isInfected ? INFECTED_COLOR : player.color
        }99)`,
        transition: isFrozen ? "none" : "all 100ms linear",
      }}
    >
      <div
        className={`w-full h-full rounded-md flex items-center justify-center transition-all duration-300 ${itClass} ${shieldClass}`}
        style={{
          backgroundColor: player.isInfected ? INFECTED_COLOR : player.color,
          opacity: isSlowed ? 0.7 : 1.0,
        }}
      >
        {isFrozen && (
          <FreezeIcon className="w-3/4 h-3/4 text-white animate-pulse" />
        )}
      </div>
      <div
        className="absolute -top-5 w-full text-center text-xs font-bold whitespace-nowrap transition-all duration-200"
        style={{ color: player.isInfected ? INFECTED_COLOR : player.color }}
      >
        {player.name}
      </div>
    </div>
  );
};

export default PlayerAvatar;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/PlayerList.tsx
<DOCUMENT>
import React from "react";
import type { Player, Room } from "../types/index";
import { PLAYER_COLORS, INFECTED_COLOR } from "@constants/index";

const PlayerList: React.FC<{ room: Room; user: Omit<Player, "socketId"> }> = ({ room, user }) => {
  return (
    <div className="space-y-2 flex-grow mb-4">
      <h3 className="font-bold mb-2 text-lg text-text-primary">
        Players ({room.players.length}/{PLAYER_COLORS.length})
      </h3>
      {room.players.map((p) => (
        <div
          key={p.id}
          className={`p-2 rounded-md flex items-center justify-between text-sm ${p.isEliminated
              ? "bg-surface-200/50 text-text-secondary/50 line-through"
              : "bg-surface-200"
            }`}
        >
          <div className="flex items-center">
            <div
              className="w-4 h-4 rounded-full mr-3"
              style={{
                backgroundColor: p.isInfected ? INFECTED_COLOR : p.color,
              }}
            ></div>
            <span className="font-bold text-text-primary">
              {p.name}
              {p.id === user.id ? " (You)" : ""}
              {p.id === room.hostId ? " üëë" : ""}
            </span>
            {p.isIt && (
              <span className="ml-2 text-error font-bold animate-pulse">
                (It!)
              </span>
            )}
            {p.isInfected && (
              <span className="ml-2 font-bold animate-pulse" style={{color: INFECTED_COLOR}}>
                (Infected)
              </span>
            )}
          </div>
          <span className="font-mono font-bold text-lg text-primary">
            {p.score}
          </span>
        </div>
      ))}
    </div>
  );
};

export default PlayerList;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/ReactionsComponent.tsx
<DOCUMENT>
import React, { useEffect, useState } from "react";
import ReactionManager from "@utils/ReactionManager";
import { ReactionsPanel, ReactionOverlay } from "@components/shared/Reactions";
import { AnimatePresence, motion } from "framer-motion";

interface ReactionsComponentProps {
  buttonClassName?: string;
}

const ReactionsComponent: React.FC<ReactionsComponentProps> = ({ buttonClassName = "" }) => {
  const [latestEmoji, setLatestEmoji] = useState("");
  const [isPanelOpen, setIsPanelOpen] = useState(false);

  useEffect(() => {
    ReactionManager.onReceive((emoji: string) => {
      setLatestEmoji(emoji);
    });
    return () => {
      ReactionManager.offReceive();
    };
  }, []);

  const handleReact = (emoji: string) => {
    ReactionManager.send(emoji);
    setLatestEmoji(emoji);
  };

  return (
    <>
      <AnimatePresence>
        {!isPanelOpen && (
          <motion.button
            key="react-btn"
            onClick={() => setIsPanelOpen(true)}
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.3, ease: "easeOut" }}
            className={`w-12 h-12 bg-primary text-white text-2xl rounded-full hover:bg-primary-hover transition shadow-lg flex items-center justify-center ${buttonClassName}`}
          >
            üéâ
          </motion.button>
        )}
      </AnimatePresence>

      <ReactionsPanel
        onReact={handleReact}
        onClose={() => setIsPanelOpen(false)}
        isOpen={isPanelOpen}
      />

      <ReactionOverlay triggerEmoji={latestEmoji} />
    </>
  );
};

export default ReactionsComponent;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/Spinner.tsx
<DOCUMENT>
import React from 'react';

interface SpinnerProps {
  className?: string;
}

const Spinner: React.FC<SpinnerProps> = ({ className = 'w-12 h-12' }) => (
  <div
    className={`animate-spin rounded-full border-4 border-solid border-primary border-t-transparent ${className}`}
    role="status"
  >
    <span className="sr-only">Loading...</span>
  </div>
);

export default Spinner;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/StatusBadge.tsx
<DOCUMENT>
import React from 'react';
import { GameStatus, STATUS_CONFIG } from '@constants/index';
import {
  StatusNewIcon,
  StatusBetaIcon,
  StatusPopularIcon,
  StatusUpdatedIcon,
  StatusFeaturedIcon,
  StatusExperimentalIcon,
  StatusComingSoonIcon,
  StatusLimitedTimeIcon,
} from '@components/icons';

interface StatusBadgeProps {
  status: GameStatus;
  className?: string;
}

const iconMap = {
  StatusNewIcon,
  StatusBetaIcon,
  StatusPopularIcon,
  StatusUpdatedIcon,
  StatusFeaturedIcon,
  StatusExperimentalIcon,
  StatusComingSoonIcon,
  StatusLimitedTimeIcon,
};

const StatusBadge: React.FC<StatusBadgeProps> = ({ status, className = '' }) => {
  const config = STATUS_CONFIG[status];
  const IconComponent = iconMap[config.iconName as keyof typeof iconMap];

  if (!IconComponent) {
    return null;
  }

  return (
    <div
      className={`absolute top-2 right-2 group ${className}`}
      aria-label={`${config.label} status`}
      role="status"
    >
      <div className="relative animate-scale-in">
        {/* Glow effect for high priority statuses */}
        {config.priority >= 7 && (
          <div className={`absolute inset-0 ${config.bgColor} rounded-full blur-sm opacity-60 animate-pulse`} />
        )}
        
        {/* The icon badge */}
        <div
          className={`relative w-6 h-6 ${config.bgColor} rounded-full p-1 shadow-lg transition-all duration-300 hover:scale-110 cursor-pointer ${config.animation}`}
        >
          <IconComponent 
            className={`w-full h-full ${config.color} drop-shadow-sm`}
            aria-hidden="true"
          />
        </div>

        {/* Modern tooltip */}
        <div className="absolute top-8 right-0 opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50">
          <div className="bg-surface-200 text-text-primary text-xs px-2 py-1 rounded-md shadow-lg whitespace-nowrap border border-border">
            {config.label}
            {/* Tooltip arrow */}
            <div className="absolute -top-1 right-2 w-2 h-2 bg-surface-200 border-l border-t border-border transform rotate-45"></div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default StatusBadge;
export { StatusBadge };
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/VirtualJoystick.tsx
<DOCUMENT>
import React, { CSSProperties } from "react";

interface VirtualJoystickProps {
  joystickState: {
    position: { x: number; y: number };
    thumbPosition: { x: number; y: number };
    isActive: boolean;
  };
}

const JOYSTICK_SIZE = 80; // px
const THUMB_SIZE = 40; // px

const VirtualJoystick: React.FC<VirtualJoystickProps> = ({
  joystickState,
}) => {
  if (!joystickState.isActive) {
    return null;
  }

  const baseStyle: CSSProperties = {
    position: "fixed",
    top: joystickState.position.y - JOYSTICK_SIZE / 2,
    left: joystickState.position.x - JOYSTICK_SIZE / 2,
    width: JOYSTICK_SIZE,
    height: JOYSTICK_SIZE,
    borderRadius: "50%",
    backgroundColor: "rgba(0, 0, 0, 0.2)",
    backdropFilter: "blur(2px)",
    zIndex: 50,
    pointerEvents: "none", // Pass touches through to the game area
  };

  const thumbStyle: CSSProperties = {
    position: "absolute",
    width: THUMB_SIZE,
    height: THUMB_SIZE,
    top: (JOYSTICK_SIZE - THUMB_SIZE) / 2 + joystickState.thumbPosition.y,
    left: (JOYSTICK_SIZE - THUMB_SIZE) / 2 + joystickState.thumbPosition.x,
    borderRadius: "50%",
    backgroundColor: "rgba(255, 255, 255, 0.4)",
    transition: "top 50ms, left 50ms",
  };

  return (
    <div style={baseStyle}>
      <div style={thumbStyle}></div>
    </div>
  );
};

export default VirtualJoystick;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/GameUI/HeistPanicUI.tsx
<DOCUMENT>
import React from "react";
import type { Player, Room } from "../../types/index";
import { GameMode } from "../../types/index";
import { useDeviceDetection } from "@hooks/useDeviceDetection";

const HeistPanicUI: React.FC<{
  room: Room;
  user: Omit<Player, "socketId">;
  onGuessSubmit: () => void;
}> = ({ room, user, onGuessSubmit }) => {
  const { isMobile } = useDeviceDetection();
  const self = room.players.find((p) => p.id === user.id);
  const isFrozen = self?.effects?.some(
    (effect) => effect.type === "frozen" && effect.expires > Date.now()
  );

  const handleGuessSubmit = (e: React.MouseEvent | React.TouchEvent) => {
    e.stopPropagation();
    if (!isFrozen) {
      onGuessSubmit();
    }
  };

  if (
    room.gameMode !== GameMode.HEIST_PANIC ||
    room.gameState.status !== "playing"
  )
    return null;

  return (
    <div className="flex flex-col items-center space-y-2">
      <button
        onClick={handleGuessSubmit}
        onTouchStart={handleGuessSubmit}
        disabled={!!isFrozen}
        className="w-full bg-warning hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-md focus:outline-none focus:shadow-outline transition-colors disabled:bg-surface-200 disabled:text-text-secondary disabled:cursor-not-allowed"
      >
        {isFrozen
          ? "Frozen!"
          : `Attempt Guess${!isMobile ? " (Press Space)" : ""}`}
      </button>
    </div>
  );
};

export default HeistPanicUI;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/GameUI/InfectionAbilityButton.tsx
<DOCUMENT>
import React, { useState, useEffect } from "react";
import type { Player, Room } from "../../types/index";
import { GameMode } from "../../types/index";
import { GAME_SETTINGS } from "@constants/index";
import { useDeviceDetection } from "@hooks/useDeviceDetection";

const InfectionAbilityButton: React.FC<{
  room: Room;
  user: Omit<Player, "socketId">;
  onAction: () => void;
}> = ({ room, user, onAction }) => {
  const [cooldown, setCooldown] = useState(0);
  const [isPending, setIsPending] = useState(false); // Track pending action
  const self = room.players.find((p) => p.id === user.id);
  const { isMobile } = useDeviceDetection();
  const { SPRINT_COOLDOWN, SHIELD_COOLDOWN } =
    GAME_SETTINGS[GameMode.INFECTION_ARENA];

  useEffect(() => {
    let intervalId: number | undefined;
    if (
      self &&
      room.gameMode === GameMode.INFECTION_ARENA &&
      room.gameState.status === "playing"
    ) {
      intervalId = window.setInterval(() => {
        const now = Date.now();
        const lastUsed = self.isInfected
          ? self.lastSprintTime
          : self.lastShieldTime;
        const totalCooldown = self.isInfected
          ? SPRINT_COOLDOWN
          : SHIELD_COOLDOWN;
        if (lastUsed) {
          const remaining = Math.max(0, totalCooldown - (now - lastUsed));
          setCooldown(Math.ceil(remaining / 1000));
          if (remaining === 0) {
            setIsPending(false); // Clear pending state when cooldown ends
          }
        } else {
          setCooldown(0);
          setIsPending(false);
        }
      }, 100); // Reduced interval for smoother updates
    }
    return () => {
      if (intervalId) clearInterval(intervalId);
    };
  }, [
    self,
    room.gameMode,
    room.gameState.status,
    SPRINT_COOLDOWN,
    SHIELD_COOLDOWN,
  ]);

  if (room.gameMode !== GameMode.INFECTION_ARENA) return null;

  const abilityName = self?.isInfected ? "Sprint" : "Shield";
  const isDisabled = cooldown > 0 || isPending;

  const handleAction = (e: React.MouseEvent | React.TouchEvent) => {
    e.stopPropagation();
    if (!isDisabled) {
      setIsPending(true); // Immediately set pending state
      setCooldown(self?.isInfected ? SPRINT_COOLDOWN / 1000 : SHIELD_COOLDOWN / 1000); // Set initial cooldown
      onAction();
    }
  };

  return (
    <button
      onClick={handleAction}
      onTouchStart={handleAction}
      disabled={isDisabled}
      className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-md focus:outline-none focus:shadow-outline transition-colors disabled:bg-surface-200 disabled:text-text-secondary disabled:cursor-not-allowed"
    >
      {isDisabled
        ? `${abilityName} (${cooldown}s)`
        : `Use ${abilityName}${!isMobile ? " (Space)" : ""}`}
    </button>
  );
};

export default InfectionAbilityButton;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/GameUI/SpyDecodeUI.tsx
<DOCUMENT>
import React from "react";
import type { Player, Room } from "../../types/index";
import { socketService } from "@services/socketService";

const SpyDecodeUI: React.FC<{ room: Room; user: Omit<Player, "socketId"> }> = ({
  room,
  user,
}) => {
  const { gameState } = room;
  const self = room.players.find((p) => p.id === user.id);

  if (gameState.phase === "reveal") {
    const spy = room.players.find((p) => p.isSpy);
    return (
      <div className="bg-indigo-900/40 text-indigo-200 rounded-md p-3 text-center mb-4 border border-indigo-500/30">
        <h4 className="font-bold">Round Over!</h4>
        <p>
          The correct code was:{" "}
          <span className="font-bold">
            {
              gameState.codes?.find((c) => c.id === gameState.correctCodeId)
                ?.value
            }
          </span>
        </p>
        <p>
          The spy was: <span className="font-bold">{spy?.name}</span>
        </p>
      </div>
    );
  }

  return (
    <div className="bg-indigo-900/40 rounded-md p-3 mb-4 border border-indigo-500/30">
      <h4 className="font-bold text-center text-indigo-200 mb-2">
        {self?.isSpy ? "You are the SPY!" : "Find the correct code!"}
      </h4>
      {self?.isSpy && (
        <p className="text-center text-xs text-warning mb-2">
          Secret Code:{" "}
          <span className="font-bold tracking-widest">
            {
              gameState.codes?.find((c) => c.id === gameState.correctCodeId)
                ?.value
            }
          </span>
        </p>
      )}

      {gameState.phase === "guessing" && (
        <div className="grid grid-cols-3 gap-2">
          {gameState.codes?.map((code) => (
            <button
              key={code.id}
              onClick={() =>
                socketService.submitGuess(room.id, user.id, code.id)
              }
              disabled={!!self?.guess}
              className={`p-2 rounded-md font-bold text-white transition-colors ${self?.guess === code.id
                  ? "bg-accent"
                  : "bg-indigo-600 hover:bg-indigo-700"
                } disabled:opacity-50 disabled:cursor-not-allowed`}
            >
              {code.value}
            </button>
          ))}
        </div>
      )}
      {gameState.phase === "signaling" && (
        <p className="text-center text-xs text-indigo-300">
          Signal the code to your allies...
        </p>
      )}
    </div>
  );
};

export default SpyDecodeUI;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/components/shared/Reactions.tsx
<DOCUMENT>
import React, { useEffect, useState, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";

interface ReactionBurst {
  id: string;
  emoji: string;
  left: string;
  xDrift: number;
  rotation: number;
}

interface ReactionsPanelProps {
  onReact: (emoji: string) => void;
  availableReactions?: string[];
  className?: string;
  onClose?: () => void;
  isOpen?: boolean;
}

const DEFAULT_REACTIONS = ["üëç", "üòÇ", "üòç", "üòÆ", "üò¢", "üëè"];

const ReactionsPanel: React.FC<ReactionsPanelProps> = ({
  onReact,
  availableReactions = DEFAULT_REACTIONS,
  className = "",
  onClose,
  isOpen = false,
}) => {
  const constraintsRef = useRef<HTMLDivElement>(null);

  return (
    <div ref={constraintsRef} className="fixed inset-0 z-50 pointer-events-none">
      <AnimatePresence>
        {isOpen && (
          <motion.div
            drag
            dragConstraints={constraintsRef}
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.3, ease: "easeOut" }}
            className={`pointer-events-auto absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2
              rounded-md border border-border shadow-xl px-5 pb-4 pt-3 w-fit
              bg-surface-100 text-text-primary backdrop-blur-md ${className}`}
          >
            <div className="flex justify-end mb-2">
              <button
                onClick={onClose}
                className="text-text-secondary hover:text-white text-3xl font-bold leading-none transition"
                aria-label="Close"
              >
                √ó
              </button>
            </div>
            <div className="flex gap-3 justify-center flex-wrap">
              {availableReactions.map((emoji) => (
                <button
                  key={emoji}
                  onClick={() => onReact(emoji)}
                  className="text-3xl sm:text-4xl hover:scale-125 transition-transform duration-200"
                >
                  {emoji}
                </button>
              ))}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

interface ReactionOverlayProps {
  triggerEmoji: string;
}

const ReactionOverlay: React.FC<ReactionOverlayProps> = ({ triggerEmoji }) => {
  const [reactions, setReactions] = useState<ReactionBurst[]>([]);

  useEffect(() => {
    if (!triggerEmoji) return;

    const leftPercent = Math.random() * 60 + 20;
    const newReaction: ReactionBurst = {
      id: crypto.randomUUID(),
      emoji: triggerEmoji,
      left: `${leftPercent}%`,
      xDrift: (Math.random() - 0.5) * 100,
      rotation: Math.random() * 40 - 20,
    };

    setReactions((prev) => [...prev, newReaction]);

    const cleanupTimer = setTimeout(() => {
      setReactions((prev) => prev.filter((r) => r.id !== newReaction.id));
    }, 2200);

    return () => clearTimeout(cleanupTimer);
  }, [triggerEmoji]);

  return (
    <div className="fixed bottom-20 left-0 w-full pointer-events-none z-40">
      <AnimatePresence>
        {reactions.map((reaction) => (
          <motion.div
            key={reaction.id}
            initial={{ opacity: 0, y: 0, scale: 0.6, x: 0 }}
            animate={{
              opacity: [0, 1, 1, 0],
              y: [-10, -80, -160, -240],
              scale: [0.6, 1.2, 1, 0.8],
              x: [0, reaction.xDrift * 0.3, reaction.xDrift * 0.6, reaction.xDrift],
              rotate: reaction.rotation,
            }}
            transition={{ duration: 2.2, ease: "easeOut" }}
            className="absolute text-3xl sm:text-4xl select-none"
            style={{ left: reaction.left }}
          >
            {reaction.emoji}
          </motion.div>
        ))}
      </AnimatePresence>
    </div>
  );
};

export { ReactionsPanel, ReactionOverlay };
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/constants/index.ts
<DOCUMENT>
import { GameMode } from "../types";

export const GRID_SIZE = 20;
export const CELL_SIZE = 32;

export const PLAYER_COLORS = [
  "#58A6FF", // primary
  "#3FB950", // accent
  "#F778BA", // accent-secondary
  "#F0A500", // warning
  "#A371F7", // violet
  "#FBBF24", // amber
  "#22D3EE", // cyan
  "#F85149", // error
];

export const INFECTED_COLOR = "#7EE787"; // A bright, sickly green

export const GAME_DESCRIPTIONS: Record<string, string> = {
  [GameMode.TAG]:
    "One player is 'It'. Avoid being tagged to score points. If you're tagged, you're It!",
  [GameMode.TERRITORY_CONTROL]:
    "Claim as many tiles as you can by walking over them. Most tiles in 60 seconds wins!",
  [GameMode.MAZE_RACE]:
    "Be the first to navigate the maze from start to finish. Watch out for dead ends!",
  [GameMode.INFECTION_ARENA]:
    "One player is the Virus. Evade infection or spread it. Last clean player standing wins!",
  [GameMode.TRAP_RUSH]:
    "Race to the finish line across a field of hidden traps. Watch your step!",
  [GameMode.SPY_AND_DECODE]:
    "A secret spy knows the code. They must signal it to you. Guess correctly without being caught!",
  [GameMode.HEIST_PANIC]:
    "Find the correct code pad to escape the vault. A wrong guess will stun you!",
};

export interface GameInstruction {
  title: string;
  objective: string;
  rules: string[];
  controls: {
    desktop: string[];
    mobile: string[];
  };
}

export const GAME_INSTRUCTIONS: Record<GameMode, GameInstruction> = {
  [GameMode.TAG]: {
    title: "How to Play: Tag",
    objective:
      "Earn points by avoiding being 'It'. The player with the most points at the end wins.",
    rules: [
      "One player is randomly chosen to be 'It' at the start.",
      "If you are 'It', your goal is to tag another player by moving onto their square.",
      "When you tag someone, they become 'It', and you are safe.",
      "Players who are not 'It' earn points for every second they remain untagged.",
    ],
    controls: {
      desktop: ["Use Arrow Keys or WASD to move your character."],
      mobile: ["Use the on-screen joystick to move your character."],
    },
  },
  [GameMode.TERRITORY_CONTROL]: {
    title: "How to Play: Territory Control",
    objective: "Claim the most tiles for your color within the time limit.",
    rules: [
      "Move your character to paint the tiles on the grid with your color.",
      "You can claim uncolored tiles or steal tiles from other players by moving over them.",
      "The player who has claimed the most tiles when the 60-second timer runs out is the winner.",
    ],
    controls: {
      desktop: ["Use Arrow Keys or WASD to move your character."],
      mobile: ["Use the on-screen joystick to move your character."],
    },
  },
  [GameMode.MAZE_RACE]: {
    title: "How to Play: Maze Race",
    objective: "Be the first player to reach the green exit of the maze.",
    rules: [
      "All players start at a random position in the maze.",
      "Navigate through the passages to find the exit (green tile).",
      "You cannot move through the dark gray walls of the maze.",
      "The first player to touch the green exit wins the round.",
    ],
    controls: {
      desktop: ["Use Arrow Keys or WASD to move your character."],
      mobile: ["Use the on-screen joystick to move your character."],
    },
  },
  [GameMode.INFECTION_ARENA]: {
    title: "How to Play: Infection Arena",
    objective:
      "As a Survivor, avoid infection until time runs out. As the Virus, infect all Survivors.",
    rules: [
      "One player starts as the 'Virus' (infected), and all others are 'Survivors'.",
      "Virus Win Condition: Infect every other player.",
      "Survivor Win Condition: At least one survivor must remain uninfected when the timer ends.",
    ],
    controls: {
      desktop: [
        "Survivors: Press SPACE to activate a temporary shield that blocks infection.",
        "Virus: Press SPACE to use a short-duration sprint to catch Survivors.",
        "Both abilities have a cooldown period after use.",
      ],
      mobile: [
        "Survivors: Tap the 'Use Shield' button to block infection.",
        "Virus: Tap the 'Use Sprint' button for a burst of speed.",
        "Both abilities have a cooldown period after use.",
      ],
    },
  },
  [GameMode.TRAP_RUSH]: {
    title: "How to Play: Trap Rush",
    objective:
      "Be the first player to cross the checkered finish line at the bottom of the grid.",
    rules: [
      "The grid is filled with hidden traps that are revealed when you step on them.",
      "‚ùÑÔ∏è Freeze Trap: Freezes you in place for a few seconds.",
      "üåÄ Teleport Trap: Instantly sends you back several rows.",
      "üêå Slow Trap: Reduces your movement speed for a few seconds.",
      "Plan your path carefully and be wary of where other players have gone!",
    ],
    controls: {
      desktop: ["Use Arrow Keys or WASD to move your character."],
      mobile: ["Use the on-screen joystick to move your character."],
    },
  },
  [GameMode.SPY_AND_DECODE]: {
    title: "How to Play: Spy & Decode",
    objective:
      "As an Agent, identify the secret code. As the Spy, trick the Agents.",
    rules: [
      "One player is secretly the 'Spy'; all others are 'Agents'.",
      "The Spy is shown the correct code. During the 'Signaling Phase', the Spy must use their movement to give clues.",
      "During the 'Guessing Phase', all players vote for the code they think is correct.",
      "The Agents win if at least one Agent guesses the code correctly.",
      "The Spy wins if NO Agents guess correctly, proving their deception was successful.",
    ],
    controls: {
      desktop: [
        "Use Arrow Keys or WASD to move during the signaling phase. Use your mouse to click your guess.",
      ],
      mobile: [
        "Use the on-screen joystick to move during the signaling phase. Tap your guess on the screen.",
      ],
    },
  },
  [GameMode.HEIST_PANIC]: {
    title: "How to Play: Heist Panic",
    objective: "Be the first to guess the correct code and escape the vault.",
    rules: [
      "Multiple code pads are scattered around the vault.",
      "Only one pad has the correct code.",
      "Move onto a pad and attempt to guess the code.",
      "If you guess correctly, you win!",
      "If you guess wrong, you will be stunned and unable to move for 3 seconds.",
    ],
    controls: {
      desktop: [
        "Use Arrow Keys or WASD to move.",
        "Press SPACE to guess when on a code pad.",
      ],
      mobile: [
        "Use the on-screen joystick to move.",
        "Tap the 'Attempt Guess' button when on a code pad.",
      ],
    },
  },
};

export const GAME_SETTINGS = {
  [GameMode.TAG]: {
    POINT_INTERVAL: 1000, // ms
  },
  [GameMode.TERRITORY_CONTROL]: {
    TIME_LIMIT: 60, // seconds
  },
  [GameMode.MAZE_RACE]: {
    // No specific settings needed here for now
  },
  [GameMode.INFECTION_ARENA]: {
    TIME_LIMIT: 60, // seconds
    SPRINT_DURATION: 1500, // ms
    SPRINT_COOLDOWN: 5000, // ms
    SHIELD_DURATION: 2000, // ms
    SHIELD_COOLDOWN: 10000, // ms
  },
  [GameMode.TRAP_RUSH]: {
    TRAP_DENSITY: 0.2, // 20% of tiles are traps
    SLOW_DURATION: 2000, // ms
    FREEZE_DURATION: 2000, // ms
    TELEPORT_DISTANCE: 5, // tiles
  },
  [GameMode.SPY_AND_DECODE]: {
    SIGNAL_TIME: 20, // seconds
    GUESS_TIME: 10, // seconds
    DECOY_CODES: ["ALPHA", "BRAVO", "CHARLIE", "DELTA", "ECHO"],
  },
  [GameMode.HEIST_PANIC]: {
    TIME_LIMIT: 90, // seconds
    NUM_PADS: 5,
    STUN_DURATION: 3000, // ms
  },
};

// Game Status Types
export enum GameStatus {
  NEW = "NEW",
  BETA = "BETA",
  POPULAR = "POPULAR",
  UPDATED = "UPDATED",
  FEATURED = "FEATURED",
  EXPERIMENTAL = "EXPERIMENTAL",
  COMING_SOON = "COMING_SOON",
  LIMITED_TIME = "LIMITED_TIME",
}

// Status Configuration
export interface StatusConfig {
  label: string;
  iconName: string;
  color: string;
  bgColor: string;
  animation: string;
  priority: number; // Higher number = higher priority if multiple statuses
}

export const STATUS_CONFIG: Record<GameStatus, StatusConfig> = {
  [GameStatus.NEW]: {
    label: "New",
    iconName: "StatusNewIcon",
    color: "text-amber-100",
    bgColor: "bg-amber-500",
    animation: "animate-pulse",
    priority: 8,
  },
  [GameStatus.BETA]: {
    label: "Beta",
    iconName: "StatusBetaIcon",
    color: "text-blue-100",
    bgColor: "bg-blue-500",
    animation: "animate-bounce-subtle",
    priority: 6,
  },
  [GameStatus.POPULAR]: {
    label: "Popular",
    iconName: "StatusPopularIcon",
    color: "text-green-100",
    bgColor: "bg-green-500",
    animation: "animate-glow-soft",
    priority: 4,
  },
  [GameStatus.UPDATED]: {
    label: "Updated",
    iconName: "StatusUpdatedIcon",
    color: "text-purple-100",
    bgColor: "bg-purple-500",
    animation: "animate-fade-in",
    priority: 3,
  },
  [GameStatus.FEATURED]: {
    label: "Featured",
    iconName: "StatusFeaturedIcon",
    color: "text-pink-100",
    bgColor: "bg-pink-500",
    animation: "animate-shimmer",
    priority: 7,
  },
  [GameStatus.EXPERIMENTAL]: {
    label: "Experimental",
    iconName: "StatusExperimentalIcon",
    color: "text-orange-100",
    bgColor: "bg-orange-500",
    animation: "animate-pulse",
    priority: 5,
  },
  [GameStatus.COMING_SOON]: {
    label: "Coming Soon",
    iconName: "StatusComingSoonIcon",
    color: "text-gray-100",
    bgColor: "bg-gray-500",
    animation: "animate-fade-in",
    priority: 2,
  },
  [GameStatus.LIMITED_TIME]: {
    label: "Limited Time",
    iconName: "StatusLimitedTimeIcon",
    color: "text-red-100",
    bgColor: "bg-red-500",
    animation: "animate-pulse",
    priority: 9,
  },
};

// Game Mode Status Configuration - Only define games that have special status
// If a game is not in this list, it will have no badge (default/normal)
export const GAME_MODE_STATUS: Partial<Record<GameMode, GameStatus[]>> = {
  [GameMode.MAZE_RACE]: [GameStatus.UPDATED],

  [GameMode.HEIST_PANIC]: [GameStatus.NEW],
  // Add new games here only if they need a special status
  // Example: [GameMode.NEW_GAME]: [GameStatus.NEW],
  // Example: [GameMode.SOME_GAME]: [GameStatus.UPDATED, GameStatus.POPULAR], // Will show highest priority
};

// Helper function to get the highest priority status
export const getGameModeStatus = (mode: GameMode): GameStatus | null => {
  const statuses = GAME_MODE_STATUS[mode];
  if (!statuses || statuses.length === 0) return null;

  // Return the status with highest priority
  return statuses.reduce((highest, current) => {
    return STATUS_CONFIG[current].priority > STATUS_CONFIG[highest].priority
      ? current
      : highest;
  });
};
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/contexts/GameContext.tsx
<DOCUMENT>
import React, { createContext, useEffect, useContext, useReducer } from "react";
import type { Player, Room } from "../types";
import { GameMode } from "../types";
import { socketService } from "@services/socketService";

interface GameContextType {
  user: Omit<Player, "socketId"> | null;
  room: Room | null;
  isLoading: boolean;
  login: (username: string) => void;
  joinRoom: (room: Room) => void;
  leaveRoom: () => void;
  endGame: () => void;
  logout: () => void;
  heistPadFeedback: { [padId: string]: 'correct' | 'incorrect' };
}

const GameContext = createContext<GameContextType | undefined>(undefined);

type GameAction =
  | { type: "SET_IS_LOADING"; payload: boolean }
  | { type: "SET_USER"; payload: Omit<Player, "socketId"> | null }
  | { type: "SET_ROOM"; payload: Room | null }
  | { type: "PLAYER_JOINED"; payload: Player }
  | { type: "PLAYER_LEFT"; payload: { playerId: string } }
  | { type: "HOST_CHANGED"; payload: { newHostId: string } }
  | {
    type: "GAME_MODE_CHANGED";
    payload: { gameMode: Room["gameMode"]; gameState: Room["gameState"] };
  }
  | { type: "GAME_STARTED"; payload: { room: Room } }
  | {
    type: "PLAYER_MOVED";
    payload: { playerId: string; x: number; y: number };
  }
  | { type: "PLAYER_TAGGED"; payload: { oldIt: string; newIt: string } }
  | {
    type: "TILE_CLAIMED";
    payload: { x: number; y: number; playerId: string; color: string };
  }
  | { type: "PLAYER_INFECTED"; payload: { playerId: string } }
  | {
    type: "ABILITY_ACTIVATED";
    payload: {
      playerId: string;
      ability: "sprint" | "shield";
      expires: number;
    };
  }
  | { type: "TRAP_TRIGGERED"; payload: { x: number; y: number; type: string } }
  | {
    type: "PLAYER_EFFECT";
    payload: { playerId: string; type: "frozen" | "slow"; expires: number };
  }
  | { type: "PAD_GUESSED"; payload: { padId: string; correct: boolean } }
  | { type: "CLEAR_PAD_FEEDBACK"; payload: { padId: string } }
  | { type: "TIMER_UPDATE"; payload: { time: number } }
  | {
    type: "SCORES_UPDATE";
    payload: { scores: { id: string; score: number }[] };
  }
  | {
    type: "PHASE_CHANGED";
    payload: { phase: Room["gameState"]["phase"]; timer: number };
  }
  | { type: "PLAYER_GUESSED"; payload: { playerId: string; guess: string } }
  | { type: "GAME_OVER"; payload: { winner: Player | { name: string } | null; players: Player[] } };

interface GameState {
  user: Omit<Player, "socketId"> | null;
  room: Room | null;
  isLoading: boolean;
  heistPadFeedback: { [padId: string]: 'correct' | 'incorrect' };
}

const initialState: GameState = {
  user: null,
  room: null,
  isLoading: true,
  heistPadFeedback: {},
};

const gameReducer = (state: GameState, action: GameAction): GameState => {
  switch (action.type) {
    case "SET_IS_LOADING":
      return { ...state, isLoading: action.payload };
    case "SET_USER":
      return { ...state, user: action.payload };
    case "SET_ROOM":
      return { ...state, room: action.payload };
    case "PLAYER_JOINED":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: [...state.room.players, action.payload],
        },
      };
    case "PLAYER_LEFT":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: state.room.players.filter(
            (p) => p.id !== action.payload.playerId
          ),
        },
      };
    case "HOST_CHANGED":
      if (!state.room) return state;
      return {
        ...state,
        room: { ...state.room, hostId: action.payload.newHostId },
      };
    case "GAME_MODE_CHANGED":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          gameMode: action.payload.gameMode,
          gameState: action.payload.gameState,
        },
      };
    case "GAME_STARTED":
      return { ...state, room: action.payload.room };
    case "PLAYER_MOVED":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: state.room.players.map((p) =>
            p.id === action.payload.playerId
              ? { ...p, x: action.payload.x, y: action.payload.y }
              : p
          ),
        },
      };
    case "PLAYER_TAGGED":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: state.room.players.map((p) => {
            if (p.id === action.payload.oldIt) return { ...p, isIt: false };
            if (p.id === action.payload.newIt) return { ...p, isIt: true };
            return p;
          }),
        },
      };
    case "TILE_CLAIMED": {
      if (!state.room || !state.room.gameState.tiles) return state;
      const newTiles = state.room.gameState.tiles.map((row) => [...row]);
      newTiles[action.payload.y][action.payload.x] = {
        claimedBy: action.payload.playerId,
        color: action.payload.color,
      };
      return {
        ...state,
        room: {
          ...state.room,
          gameState: { ...state.room.gameState, tiles: newTiles },
        },
      };
    }
    case "TIMER_UPDATE":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          gameState: { ...state.room.gameState, timer: action.payload.time },
        },
      };
    case "GAME_OVER":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          gameState: {
            ...state.room.gameState,
            status: "finished",
            winner: action.payload.winner,
          },
          players: action.payload.players,
        },
      };
    case "PLAYER_INFECTED":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: state.room.players.map((p) =>
            p.id === action.payload.playerId ? { ...p, isInfected: true } : p
          ),
        },
      };
    case "ABILITY_ACTIVATED":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: state.room.players.map((p) => {
            if (p.id === action.payload.playerId) {
              if (action.payload.ability === "sprint")
                return {
                  ...p,
                  sprintUntil: action.payload.expires,
                  lastSprintTime: Date.now(),
                };
              if (action.payload.ability === "shield")
                return {
                  ...p,
                  shieldUntil: action.payload.expires,
                  lastShieldTime: Date.now(),
                };
            }
            return p;
          }),
        },
      };
    case "TRAP_TRIGGERED": {
      if (!state.room || !state.room.gameState.trapMap) return state;
      const newTrapMap = state.room.gameState.trapMap.map((r) =>
        r.map((c) => (c ? { ...c } : null))
      );
      if (newTrapMap[action.payload.y][action.payload.x]) {
        newTrapMap[action.payload.y][action.payload.x]!.revealed = true;
      }
      return {
        ...state,
        room: {
          ...state.room,
          gameState: { ...state.room.gameState, trapMap: newTrapMap },
        },
      };
    }
    case "PLAYER_EFFECT":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: state.room.players.map((p) => {
            if (p.id === action.payload.playerId) {
              const newEffects = [
                ...(p.effects || []),
                { type: action.payload.type, expires: action.payload.expires },
              ];
              return { ...p, effects: newEffects };
            }
            return p;
          }),
        },
      };
    case "SCORES_UPDATE":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: state.room.players.map((p) => {
            const update = action.payload.scores.find((s) => s.id === p.id);
            return update ? { ...p, score: update.score } : p;
          }),
        },
      };
    case "PAD_GUESSED":
      if (!state.room || state.room.gameMode !== GameMode.HEIST_PANIC) return state;
      return {
        ...state,
        heistPadFeedback: {
          ...state.heistPadFeedback,
          [action.payload.padId]: action.payload.correct ? 'correct' : 'incorrect',
        },
      };
    case "CLEAR_PAD_FEEDBACK": {
      const newFeedback = { ...state.heistPadFeedback };
      delete newFeedback[action.payload.padId];
      return { ...state, heistPadFeedback: newFeedback };
    }
    case "PHASE_CHANGED":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          gameState: {
            ...state.room.gameState,
            phase: action.payload.phase,
            timer: action.payload.timer,
          },
        },
      };
    case "PLAYER_GUESSED":
      if (!state.room) return state;
      return {
        ...state,
        room: {
          ...state.room,
          players: state.room.players.map((p) =>
            p.id === action.payload.playerId
              ? { ...p, guess: action.payload.guess }
              : p
          ),
        },
      };
    default:
      return state;
  }
};

interface GameProviderProps {
  children: React.ReactNode;
}

export const GameProvider: React.FC<GameProviderProps> = ({ children }) => {
  const [state, dispatch] = useReducer(gameReducer, initialState);

  useEffect(() => {
    socketService.connect();

    const savedUsername = localStorage.getItem("pixel-arena-username");
    if (savedUsername) {
      dispatch({
        type: "SET_USER",
        payload: {
          id: crypto.randomUUID(),
          name: savedUsername,
          x: 0,
          y: 0,
          score: 0,
          color: "",
          isIt: false,
          isEliminated: false,
        },
      });
    }
    dispatch({ type: "SET_IS_LOADING", payload: false });

    // Setup all listeners
    socketService.onGameStarted((data) =>
      dispatch({ type: "GAME_STARTED", payload: data })
    );
    socketService.onPlayerJoined((data) =>
      dispatch({ type: "PLAYER_JOINED", payload: data.player })
    );
    socketService.onPlayerLeft((data) =>
      dispatch({ type: "PLAYER_LEFT", payload: data })
    );
    socketService.onHostChanged((data) =>
      dispatch({ type: "HOST_CHANGED", payload: data })
    );
    socketService.onGameModeChanged((data) =>
      dispatch({ type: "GAME_MODE_CHANGED", payload: data })
    );
    socketService.onPlayerMoved((data) =>
      dispatch({ type: "PLAYER_MOVED", payload: data })
    );
    socketService.onPlayerTagged((data) =>
      dispatch({ type: "PLAYER_TAGGED", payload: data })
    );
    socketService.onTileClaimed((data) =>
      dispatch({ type: "TILE_CLAIMED", payload: data })
    );
    socketService.onPlayerInfected((data) =>
      dispatch({ type: "PLAYER_INFECTED", payload: data })
    );
    socketService.onAbilityActivated((data) =>
      dispatch({ type: "ABILITY_ACTIVATED", payload: data })
    );
    socketService.onTrapTriggered((data) =>
      dispatch({ type: "TRAP_TRIGGERED", payload: data })
    );
    socketService.onPlayerEffect((data) =>
      dispatch({ type: "PLAYER_EFFECT", payload: data })
    );
    socketService.onPadGuessed((data) => {
      dispatch({ type: "PAD_GUESSED", payload: data });
      // Clear feedback after a short delay for incorrect guesses
      if (!data.correct) {
        setTimeout(() => {
          dispatch({ type: "CLEAR_PAD_FEEDBACK", payload: { padId: data.padId } });
        }, 1000);
      }
    });
    socketService.onTimerUpdate((data) =>
      dispatch({ type: "TIMER_UPDATE", payload: data })
    );
    socketService.onScoresUpdate((data) =>
      dispatch({ type: "SCORES_UPDATE", payload: data })
    );
    socketService.onPhaseChanged((data) =>
      dispatch({ type: "PHASE_CHANGED", payload: data })
    );
    socketService.onPlayerGuessed((data) =>
      dispatch({ type: "PLAYER_GUESSED", payload: data })
    );
    socketService.onGameOver((data) =>
      dispatch({ type: "GAME_OVER", payload: data })
    );

    return () => {
      socketService.disconnect();
      socketService.offAll();
    };
  }, []);

  const login = (username: string) => {
    const newUser: Omit<Player, "socketId"> = {
      id: crypto.randomUUID(),
      name: username,
      x: 0,
      y: 0,
      score: 0,
      color: "",
      isIt: false,
      isEliminated: false,
    };
    localStorage.setItem("pixel-arena-username", username);
    dispatch({ type: "SET_USER", payload: newUser });
  };

  const joinRoom = (joinedRoom: Room) => {
    dispatch({ type: "SET_ROOM", payload: joinedRoom });
  };

  const leaveRoom = () => {
    socketService.leaveRoom();
    dispatch({ type: "SET_ROOM", payload: null });
  };

  const endGame = () => {
    dispatch({ type: "SET_ROOM", payload: null });
  };

  const logout = () => {
    dispatch({ type: "SET_USER", payload: null });
    localStorage.removeItem("pixel-arena-username");
    leaveRoom();
  };

  const value = {
    user: state.user,
    room: state.room,
    isLoading: state.isLoading,
    login,
    joinRoom,
    leaveRoom,
    endGame,
    heistPadFeedback: state.heistPadFeedback,
    logout,
  };

  return <GameContext.Provider value={value}>{children}</GameContext.Provider>;
};

export const useGame = () => {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error("useGame must be used within a GameProvider");
  }
  return context;
};

export default GameProvider;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/hooks/useDeviceDetection.ts
<DOCUMENT>
import { useState, useEffect } from 'react';

export const useDeviceDetection = () => {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    // Using `matchMedia('(pointer: coarse)')` is a more robust way to detect
    // touch-first devices (like phones and tablets) vs. devices where a fine
    // pointer (like a mouse or trackpad) is the primary input, even if they
    // have a touchscreen (like many modern laptops).
    const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
    setIsMobile(isCoarsePointer);
    
    // The pointer type doesn't typically change on resize, so a one-time check is sufficient.
  }, []);

  return { isMobile };
};
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/hooks/useFullscreen.ts
<DOCUMENT>
import { useState, useLayoutEffect, useCallback } from "react";

export const useFullscreen = () => {
  const [isFullscreen, setIsFullscreen] = useState(false);

  const enterFullscreen = useCallback((element: HTMLElement) => {
    if (element.requestFullscreen) {
      element.requestFullscreen().catch((err) => {
        console.error(
          `Error attempting to enable full-screen mode: ${err.message} (${err.name})`
        );
      });
    }
  }, []);

  const exitFullscreen = useCallback(() => {
    if (document.fullscreenElement) {
      document.exitFullscreen();
    }
  }, []);

  useLayoutEffect(() => {
    const onFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener("fullscreenchange", onFullscreenChange);
    return () =>
      document.removeEventListener("fullscreenchange", onFullscreenChange);
  }, []);

  return { isFullscreen, enterFullscreen, exitFullscreen };
};
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/hooks/usePlayerMovement.ts
<DOCUMENT>
import { useEffect, useCallback, useRef } from "react";
import { socketService } from "@services/socketService";
import type { Player, Room } from "../types";
import { GameMode } from "../types";

const MOVE_INTERVAL_MS = 120; // ms, similar to holding a key

export const usePlayerMovement = (
  user: Omit<Player, "socketId">,
  room: Room | null,
  isMobile: boolean
) => {
  const roomRef = useRef(room);
  const userRef = useRef(user);
  const moveInterval = useRef<number | null>(null);
  const lastDirection = useRef<string | null>(null);

  useEffect(() => {
    roomRef.current = room;
    userRef.current = user;
  }, [room, user]);

  const stopMovement = useCallback(() => {
    if (moveInterval.current) {
      clearInterval(moveInterval.current);
      moveInterval.current = null;
    }
    lastDirection.current = null;
  }, []);

  const handleMove = useCallback(
    (direction: string) => {
      const moveFn = () => {
        const currentRoom = roomRef.current;
        const currentUser = userRef.current;
        if (!currentRoom || !currentUser) {
          stopMovement();
          return;
        }
        const currentPlayer = currentRoom.players.find(
          (p) => p.id === currentUser.id
        );
        if (!currentPlayer || currentRoom.gameState.status !== "playing") {
          stopMovement();
          return;
        }

        let { x, y } = currentPlayer;
        switch (direction) {
          case "up":
            y -= 1;
            break;
          case "down":
            y += 1;
            break;
          case "left":
            x -= 1;
            break;
          case "right":
            x += 1;
            break;
        }
        socketService.updatePlayerPosition(currentRoom.id, currentUser.id, {
          x,
          y,
        });
      };

      if (direction !== lastDirection.current) {
        stopMovement();
        moveFn(); // Move immediately on direction change
        moveInterval.current = window.setInterval(moveFn, MOVE_INTERVAL_MS);
        lastDirection.current = direction;
      }
    },
    [stopMovement]
  );

  const handleMoveEnd = useCallback(() => {
    stopMovement();
  }, [stopMovement]);

  const handleAction = useCallback(() => {
    const currentRoom = roomRef.current;
    const currentUser = userRef.current;
    if (!currentRoom || !currentUser) return;

    const currentPlayer = currentRoom.players.find(
      (p) => p.id === currentUser.id
    );
    if (!currentPlayer || currentRoom.gameState.status !== "playing") return;

    if (currentRoom.gameMode === GameMode.INFECTION_ARENA) {
      socketService.activateAbility(currentRoom.id, currentUser.id);
    } else if (currentRoom.gameMode === GameMode.HEIST_PANIC) {
      const padUnderPlayer = currentRoom.gameState.codePads?.find(
        (p) =>
          Math.abs(p.x - currentPlayer.x) < 50 &&
          Math.abs(p.y - currentPlayer.y) < 50
      );
      if (padUnderPlayer) {
        socketService.submitHeistGuess(
          currentRoom.id,
          currentUser.id,
          padUnderPlayer.id
        );
      }
    }
  }, []);

  const handleKeyDown = useCallback(
    (event: KeyboardEvent) => {
      if (event.repeat) return;
      const currentRoom = roomRef.current;
      const currentUser = userRef.current;
      if (!currentRoom || !currentUser) return;

      const currentPlayer = currentRoom.players.find(
        (p) => p.id === currentUser.id
      );
      if (!currentPlayer || currentRoom.gameState.status !== "playing") return;

      if (event.key === " ") {
        event.preventDefault();
        handleAction();
        return;
      }

      let direction: string | null = null;
      switch (event.key) {
        case "ArrowUp":
        case "w":
          direction = "up";
          break;
        case "ArrowDown":
        case "s":
          direction = "down";
          break;
        case "ArrowLeft":
        case "a":
          direction = "left";
          break;
        case "ArrowRight":
        case "d":
          direction = "right";
          break;
        default:
          return;
      }

      if (direction) {
        event.preventDefault();
        handleMove(direction);
      }
    },
    [handleAction, handleMove]
  );

  const handleKeyUp = useCallback(
    (event: KeyboardEvent) => {
      const keyMap: Record<string, string> = {
        ArrowUp: "up",
        w: "up",
        ArrowDown: "down",
        s: "down",
        ArrowLeft: "left",
        a: "left",
        ArrowRight: "right",
        d: "right",
      };
      const direction = keyMap[event.key];
      if (direction && direction === lastDirection.current) {
        handleMoveEnd();
      }
    },
    [handleMoveEnd]
  );

  useEffect(() => {
    if (isMobile) return;

    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      stopMovement(); // Clean up on unmount
    };
  }, [handleKeyDown, handleKeyUp, isMobile, stopMovement]);

  return { handleAction, handleMove, handleMoveEnd };
};
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/pages/GamePage.tsx
<DOCUMENT>
import React, { useState, useEffect, useRef, TouchEvent } from "react";
import { GameMode, MazeRaceDifficulty, Room } from "../types/index";
import { socketService } from "@services/socketService";
import { usePlayerMovement } from "@hooks/usePlayerMovement";
import { useFullscreen } from "@hooks/useFullscreen";
import { useClipboard } from "@utils/clipboard";
import GameBoard from "@components/GameBoard";
import EndScreen from "@components/EndScreen";
import InstructionsModal from "@components/InstructionsModal";
import LoadingScreen from "@components/LoadingScreen";
import GameStatus from "@components/GameStatus";
import PlayerList from "@components/PlayerList";
import GameControls from "@components/GameControls";
import { GAME_DESCRIPTIONS } from "@constants/index";
import { useGame } from "@contexts/GameContext";
import { useDeviceDetection } from "@hooks/useDeviceDetection";
import VirtualJoystick from "@components/VirtualJoystick";
import SpyDecodeUI from "@components/GameUI/SpyDecodeUI";
import InfectionAbilityButton from "@components/GameUI/InfectionAbilityButton";
import HeistPanicUI from "@components/GameUI/HeistPanicUI";
import { EnterFullscreenIcon, InfoIcon, CheckCircleIcon } from "@components/icons";
import ReactionsComponent from "@components/ReactionsComponent";

const GamePage: React.FC = () => {
  const { user, room, leaveRoom, endGame, heistPadFeedback } = useGame();
  const { isMobile } = useDeviceDetection();
  const [isInstructionsVisible, setIsInstructionsVisible] = useState(false);
  const [requestFullscreenOnStart, setRequestFullscreenOnStart] = useState(false);
  const [selectedDifficulty, setSelectedDifficulty] = useState(MazeRaceDifficulty.EASY);
  const gameAreaRef = useRef<HTMLDivElement>(null);
  const { isFullscreen, enterFullscreen, exitFullscreen } = useFullscreen();
  const { copied, handleCopy } = useClipboard(room?.id || "");
  const [activePadId, setActivePadId] = useState<string | null>(null);
  const { handleAction, handleMove, handleMoveEnd } = usePlayerMovement(user!, room!, isMobile);

  const handleHeistGuess = () => {
    if (user && room && activePadId) {
      socketService.submitHeistGuess(room.id, user.id, activePadId);
    }
  };

  const handleInfectionAction = () => {
    if (user && room && room.gameMode === GameMode.INFECTION_ARENA) {
      handleAction(); // Use handleAction from usePlayerMovement
    }
  };

  useEffect(() => {
    const handlePlayerOnPad = (data: { playerId: string; padId: string }) => {
      if (data.playerId === user?.id) {
        setActivePadId(data.padId);
      }
    };

    const handlePlayerOffPad = (data: { playerId: string }) => {
      if (data.playerId === user?.id) {
        setActivePadId(null);
      }
    };

    socketService.onPlayerOnPad(handlePlayerOnPad);
    socketService.onPlayerOffPad(handlePlayerOffPad);

    return () => {
      socketService.offPlayerOnPad();
      socketService.offPlayerOffPad();
    };
  }, [user?.id]);

  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
      if (event.code === "Space" && !isMobile) {
        const activeElement = document.activeElement as HTMLElement;
        if (activeElement.tagName === 'BUTTON' || activeElement.closest('button')) {
          return; // Let button handle its own event
        }
        event.preventDefault();
        if (room?.gameMode === GameMode.HEIST_PANIC && activePadId) {
          handleHeistGuess();
        } else if (room?.gameMode === GameMode.INFECTION_ARENA) {
          handleInfectionAction();
        }
      }
    };

    document.addEventListener("keydown", handleKeyPress);
    return () => document.removeEventListener("keydown", handleKeyPress);
  }, [activePadId, isMobile, room?.gameMode]);

  const roomRef = useRef(room);
  useEffect(() => {
    roomRef.current = room;
  }, [room]);

  const [joystickState, setJoystickState] = useState({
    isActive: false,
    position: { x: 0, y: 0 },
    thumbPosition: { x: 0, y: 0 },
    touchId: null as number | null,
  });

  useEffect(() => {
    if (
      room?.gameState.status === "playing" &&
      !isFullscreen &&
      gameAreaRef.current
    ) {
      if (isMobile || requestFullscreenOnStart) {
        enterFullscreen(gameAreaRef.current);
      }
    }
  }, [
    room?.gameState.status,
    isMobile,
    isFullscreen,
    enterFullscreen,
    requestFullscreenOnStart,
  ]);

  useEffect(() => {
    if (room?.gameState.status !== "playing" && isFullscreen) {
      exitFullscreen();
    }
    if (
      room?.gameMode === GameMode.SPY_AND_DECODE &&
      room?.gameState.phase === "guessing" &&
      isFullscreen
    ) {
      exitFullscreen();
    }
  }, [room?.gameState, isFullscreen, exitFullscreen, room?.gameMode]);

  useEffect(() => {
    if (room?.mazeRaceSettings?.difficulty) {
      setSelectedDifficulty(room.mazeRaceSettings.difficulty);
    }
  }, [room?.mazeRaceSettings?.difficulty]);

  useEffect(() => {
    const handleDifficultyChange = (data: {
      difficulty: MazeRaceDifficulty;
      room: Room;
    }) => {
      setSelectedDifficulty(data.difficulty);
    };

    socketService.onMazeDifficultyChanged(handleDifficultyChange);
    return () => socketService.offMazeDifficultyChanged();
  }, []);

  const handleTouchStart = (e: TouchEvent<HTMLDivElement>) => {
    if (joystickState.isActive) return;
    const touch = e.changedTouches[0];
    if (!touch) return;
    const target = e.target as HTMLElement;
    if (target.closest('button, input, select')) return;
    e.preventDefault(); // Prevent window scrolling
    setJoystickState({
      isActive: true,
      position: { x: touch.clientX, y: touch.clientY },
      thumbPosition: { x: 0, y: 0 },
      touchId: touch.identifier,
    });
  };

  const handleTouchMove = (e: TouchEvent<HTMLDivElement>) => {
    if (!joystickState.isActive) return;
    const touch = Array.from(e.changedTouches).find(
      (t) => t.identifier === joystickState.touchId
    );
    if (!touch) return;
    e.preventDefault(); // Prevent window scrolling
    const { x: centerX, y: centerY } = joystickState.position;
    let dx = touch.clientX - centerX;
    let dy = touch.clientY - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const JOYSTICK_SIZE = 80;
    const THUMB_SIZE = 40;
    const radius = (JOYSTICK_SIZE - THUMB_SIZE) / 2;

    let thumbX = dx;
    let thumbY = dy;

    if (distance > radius) {
      thumbX = (dx / distance) * radius;
      thumbY = (dy / distance) * radius;
    }

    setJoystickState((prev) => ({
      ...prev,
      thumbPosition: { x: thumbX, y: thumbY },
    }));

    if (distance < radius / 3) {
      handleMoveEnd();
      return;
    }

    const angle = Math.atan2(dy, dx);
    let direction: string;
    if (angle > -Math.PI / 4 && angle <= Math.PI / 4) direction = "right";
    else if (angle > Math.PI / 4 && angle <= (3 * Math.PI) / 4)
      direction = "down";
    else if (angle > (3 * Math.PI) / 4 || angle <= (-3 * Math.PI) / 4)
      direction = "left";
    else direction = "up";

    handleMove(direction);
  };

  const handleTouchEnd = (e: TouchEvent<HTMLDivElement>) => {
    const touch = Array.from(e.changedTouches).find(
      (t) => t.identifier === joystickState.touchId
    );
    if (!touch) return;
    e.preventDefault(); // Prevent window scrolling
    handleMoveEnd();
    setJoystickState({
      isActive: false,
      position: { x: 0, y: 0 },
      thumbPosition: { x: 0, y: 0 },
      touchId: null,
    });
  };

  const handleTouchCancel = (e: TouchEvent<HTMLDivElement>) => {
    const touch = Array.from(e.changedTouches).find(
      (t) => t.identifier === joystickState.touchId
    );
    if (!touch) return;
    e.preventDefault(); // Prevent window scrolling
    handleMoveEnd();
    setJoystickState({
      isActive: false,
      position: { x: 0, y: 0 },
      thumbPosition: { x: 0, y: 0 },
      touchId: null,
    });
  };

  if (!user || !room) {
    return <LoadingScreen />;
  }

  const handleStartGame = () => {
    socketService.startGame(room.id, user.id);
  };

  const handleReEnterFullscreen = () => {
    if (gameAreaRef.current) {
      enterFullscreen(gameAreaRef.current);
    }
  };

  const isHost = room.hostId === user.id;

  if (room.gameState.status === "finished") {
    return <EndScreen room={room} onBackToLobby={endGame} />;
  }

  return (
    <>
      {isInstructionsVisible && (
        <InstructionsModal
          gameMode={room.gameMode}
          onClose={() => setIsInstructionsVisible(false)}
        />
      )}
      <div className="w-full flex flex-col lg:flex-row gap-6">
        <div
          ref={gameAreaRef}
          className={
            isFullscreen
              ? "fixed inset-0 bg-background flex items-center justify-center z-50 p-2"
              : "flex-grow flex items-center justify-center relative min-h-[300px] lg:min-h-0"
          }
          onTouchStart={
            isMobile && room.gameState.status === "playing"
              ? handleTouchStart
              : undefined
          }
          onTouchMove={
            isMobile && room.gameState.status === "playing"
              ? handleTouchMove
              : undefined
          }
          onTouchEnd={
            isMobile && room.gameState.status === "playing"
              ? handleTouchEnd
              : undefined
          }
          onTouchCancel={
            isMobile && room.gameState.status === "playing"
              ? handleTouchCancel
              : undefined
          }
        >
          {isFullscreen && (
            <GameStatus room={room} isFullscreen={isFullscreen} />
          )}
          <GameBoard
            room={room}
            heistPadFeedback={heistPadFeedback}
            user={user}
          />
          {isMobile && room.gameState.status === "playing" && (
            <VirtualJoystick joystickState={joystickState} />
          )}
          {isMobile &&
            room.gameState.status === "playing" &&
            room.gameMode === GameMode.INFECTION_ARENA &&
            isFullscreen && (
              <div className="absolute bottom-4 right-4 w-24 h-24 z-60">
                <InfectionAbilityButton
                  room={room}
                  user={user}
                  onAction={handleInfectionAction}
                />
              </div>
            )}
          {isMobile &&
            room.gameState.status === "playing" &&
            room.gameMode === GameMode.HEIST_PANIC &&
            isFullscreen &&
            activePadId && (
              <div className="absolute bottom-4 right-4 w-48 z-60">
                <HeistPanicUI
                  room={room}
                  user={user}
                  onGuessSubmit={handleHeistGuess}
                />
              </div>
            )}
          {isMobile &&
            room.gameState.status === "playing" &&
            !isFullscreen && (
              <button
                onClick={handleReEnterFullscreen}
                className="absolute top-4 right-4 z-60 p-2 bg-black/30 rounded-full text-text-primary hover:bg-black/50 transition-colors animate-pulse"
                aria-label="Enter fullscreen"
              >
                <EnterFullscreenIcon className="w-8 h-8" />
              </button>
            )}
        </div>
        {!isFullscreen && (
          <div className="lg:w-80 flex-shrink-0 bg-surface-100 border border-border rounded-lg p-4 flex flex-col">
            <div className="flex justify-between items-center mb-1">
              <h2 className="text-2xl font-bold text-text-primary">{room.gameMode}</h2>
              <button
                onClick={() => setIsInstructionsVisible(true)}
                className="flex items-center gap-2 text-text-secondary hover:text-text-primary transition-colors"
                aria-label="How to Play"
              >
                {room.gameState.status === "waiting" && (
                  <span className="text-sm font-semibold">How to play</span>
                )}
                <InfoIcon className="w-6 h-6" />
              </button>
            </div>
            <div className="flex items-center mb-2">
              <p className="text-sm text-text-secondary">
                Room Code:{" "}
                <span
                  className="font-bold text-warning tracking-widest cursor-pointer"
                  onClick={handleCopy}
                >
                  {room.id}
                </span>
              </p>
              {copied && (
                <div className="ml-2 flex items-center text-accent text-xs animate-in fade-in">
                  <CheckCircleIcon className="w-4 h-4 mr-1" />
                  <span>Copied!</span>
                </div>
              )}
            </div>
            <p className="text-sm text-text-secondary mb-4">
              {GAME_DESCRIPTIONS[room.gameMode]}
            </p>
            {room.gameMode === GameMode.SPY_AND_DECODE && (
              <SpyDecodeUI room={room} user={user} />
            )}
            <GameStatus room={room} isFullscreen={isFullscreen} />
            <PlayerList room={room} user={user} />
            {!isMobile && room.gameState.status === "waiting" && (
              <div className="flex items-center justify-center my-3">
                <input
                  id="fullscreen-checkbox"
                  type="checkbox"
                  checked={requestFullscreenOnStart}
                  onChange={(e) => setRequestFullscreenOnStart(e.target.checked)}
                  className="w-4 h-4 text-primary bg-surface-200 border-border rounded focus:ring-primary focus:ring-2"
                />
                <label
                  htmlFor="fullscreen-checkbox"
                  className="ml-2 text-sm font-medium text-text-primary"
                >
                  Play in Fullscreen
                </label>
              </div>
            )}
            {room.gameMode === GameMode.MAZE_RACE &&
              room.gameState.status === "waiting" &&
              isHost && (
                <div className="flex flex-col mb-4">
                  <label
                    htmlFor="difficulty-select"
                    className="mb-1 text-sm font-medium text-text-primary"
                  >
                    Select Difficulty
                  </label>
                  <select
                    id="difficulty-select"
                    value={selectedDifficulty}
                    onChange={(e) => {
                      const newDifficulty = e.target.value as MazeRaceDifficulty;
                      setSelectedDifficulty(newDifficulty);
                      socketService.setMazeRaceDifficulty(room.id, user.id, newDifficulty);
                    }}
                    className="p-2 bg-surface-200 border border-border text-text-primary rounded-md focus:ring-2 focus:ring-primary focus:border-primary"
                  >
                    {Object.values(MazeRaceDifficulty).map((d) => (
                      <option key={d} value={d}>
                        {d.charAt(0).toUpperCase() + d.slice(1)}
                      </option>
                    ))}
                  </select>
                </div>
              )}
              <ReactionsComponent buttonClassName="block sm:hidden mt-2"/>
            {room.gameMode === GameMode.INFECTION_ARENA &&
              room.gameState.status === "playing" && (
                <InfectionAbilityButton
                  room={room}
                  user={user}
                  onAction={handleInfectionAction}
                />
              )}
            {room.gameMode === GameMode.HEIST_PANIC &&
              room.gameState.status === "playing" &&
              activePadId && (
                <HeistPanicUI
                  room={room}
                  user={user}
                  onGuessSubmit={handleHeistGuess}
                />
              )}
            <GameControls
              room={room}
              isHost={isHost}
              onStartGame={handleStartGame}
              onLeaveRoom={leaveRoom}
            />
          </div>
        )}
      </div>
      <ReactionsComponent buttonClassName="hidden sm:block fixed bottom-6 left-6 z-50" />
    </>
  );
};

export default GamePage;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/pages/LobbyPage.tsx
<DOCUMENT>
import React, { useState, useEffect } from "react";
import { motion, easeOut } from "framer-motion";
import { GameMode } from "../types";
import { socketService } from "@services/socketService";
import { GAME_DESCRIPTIONS, PLAYER_COLORS, getGameModeStatus, GameStatus } from "@constants/index";
import {
  TagIcon,
  TerritoryIcon,
  MazeIcon,
  EnterIcon,
  CreateIcon,
  InfectionIcon,
  TrapIcon,
  SpyIcon,
  InfoIcon,
  HeistIcon,
  PowerIcon
} from "@components/icons";
import InstructionsModal from "@components/InstructionsModal";
import Spinner from "@components/Spinner";
import { useGame } from "@contexts/GameContext";
import { StatusBadge } from "@components/StatusBadge";

interface GameModeCardProps {
  mode: GameMode;
  icon: React.ReactNode;
  selected: boolean;
  onSelect: () => void;
  status?: GameStatus | null;
}

const GameModeCard: React.FC<GameModeCardProps> = ({
  mode,
  icon,
  selected,
  onSelect,
  status,
}) => {
  return (
    <div className="relative">
      <button
        onClick={onSelect}
        className={`relative overflow-hidden p-4 md:p-6 border-2 rounded-lg text-left transition-all duration-300 w-full h-full flex flex-col transform hover:scale-105 group ${selected
          ? "border-primary bg-primary/20 shadow-lg shadow-primary/20 animate-bounce-subtle"
          : "border-border bg-surface-100 hover:bg-surface-200 hover:border-primary/50 hover:shadow-lg"
          }`}
      >
        <div className="flex items-center mb-2">
          <div className="transform transition-transform duration-300 group-hover:scale-110">
            {icon}
          </div>
          <h3 className="text-xl font-bold ml-3 text-text-primary">{mode}</h3>
        </div>
        <p className="text-sm text-text-secondary flex-grow">{GAME_DESCRIPTIONS[mode]}</p>
      </button>
      {status && <StatusBadge status={status} />}
    </div>
  );
};

const containerVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: {
    opacity: 1,
    y: 0,
    transition: {
      duration: 0.6,
      ease: easeOut
    }
  }
};

const LobbyPage: React.FC = () => {
  const { user, joinRoom: onJoinRoom, logout } = useGame();
  const [selectedGameMode, setSelectedGameMode] = useState<GameMode>(
    GameMode.TAG
  );
  const [joinCode, setJoinCode] = useState("");
  const [error, setError] = useState("");
  const [availableRooms, setAvailableRooms] = useState<
    { id: string; gameMode: GameMode; playerCount: number }[]
  >([]);
  const [isInstructionsVisible, setIsInstructionsVisible] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isLoadingRooms, setIsLoadingRooms] = useState(true);

  useEffect(() => {
    const handleRoomsUpdate = (
      rooms: { id: string; gameMode: GameMode; playerCount: number }[]
    ) => {
      setAvailableRooms(rooms);
      setIsLoadingRooms(false);
    };
    socketService.onAvailableRoomsUpdate(handleRoomsUpdate);
    socketService.getAvailableRooms();

    return () => socketService.offAvailableRoomsUpdate();
  }, []);

  const handleCreateRoom = () => {
    if (isProcessing || !user) return;
    setIsProcessing(true);
    socketService.createRoom(user, selectedGameMode, onJoinRoom);
  };

  const handleJoinWithCode = (code: string) => {
    if (!code || isProcessing || !user) return;
    setIsProcessing(true);
    socketService.joinRoom(code.toUpperCase(), user, ({ room, error }) => {
      if (room) {
        onJoinRoom(room);
      } else {
        setError(error || "An unknown error occurred.");
        setTimeout(() => setError(""), 3000);
        setIsProcessing(false);
      }
    });
  };

  const gameModeIcons: Record<string, React.ReactNode> = {
    [GameMode.TAG]: <TagIcon className="h-8 w-8 text-red-500" />,
    [GameMode.TERRITORY_CONTROL]: (
      <TerritoryIcon className="h-8 w-8 text-green-500" />
    ),
    [GameMode.MAZE_RACE]: <MazeIcon className="h-8 w-8 text-yellow-500" />,
    [GameMode.HEIST_PANIC]: (
      <HeistIcon className="h-8 w-8 text-blue-500" />
    ),
    [GameMode.INFECTION_ARENA]: (
      <InfectionIcon className="h-8 w-8 text-lime-400" />
    ),
    [GameMode.TRAP_RUSH]: <TrapIcon className="h-8 w-8 text-orange-500" />,
    [GameMode.SPY_AND_DECODE]: <SpyIcon className="h-8 w-8 text-indigo-500" />,
  };

  return (
    <>
      {isInstructionsVisible && (
        <InstructionsModal
          gameMode={selectedGameMode}
          onClose={() => setIsInstructionsVisible(false)}
        />
      )}
      <motion.div className="w-full max-w-6xl mx-auto animate-in fade-in duration-500">
        <div className="text-center mb-8 relative pt-10 sm:pt-10">
          <h1 className="text-4xl font-bold tracking-wider text-text-primary">GAME LOBBY</h1>
          <p className="text-text-secondary mt-2">
            Welcome,{" "}
            <span className="text-primary font-bold">{user?.name}</span>!
            Choose your game.
          </p>

          <button
            onClick={logout}
            className="absolute top-0 right-0 w-10 h-10 bg-error/20 hover:bg-error/40 border border-error/50 rounded-full flex items-center justify-center transition-all duration-300 hover:shadow-lg hover:shadow-error/30 group"
            aria-label="Logout"
          >
            <PowerIcon className="w-5 h-5 text-error group-hover:scale-110 transition-transform" />
          </button>
        </div>
      </motion.div>

      <motion.div
        className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        {(Object.values(GameMode) as GameMode[]).map((mode) => {
          const status = getGameModeStatus(mode);
          return (
            <GameModeCard
              key={mode}
              mode={mode}
              icon={gameModeIcons[mode]}
              selected={selectedGameMode === mode}
              onSelect={() => setSelectedGameMode(mode)}
              status={status}
            />
          );
        })}
      </motion.div>

      <motion.div
        className="grid grid-cols-1 md:grid-cols-2 gap-6"
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        <div className="bg-surface-100 border border-border rounded-lg p-6 flex flex-col">
          <h2 className="text-2xl font-bold mb-4 flex items-center text-text-primary">
            <CreateIcon className="w-8 h-8 mr-2 text-accent" /> Create a
            Room
          </h2>
          <p className="text-text-secondary mb-4 flex-grow">
            Start a new game of{" "}
            <span className="font-bold text-text-primary">{selectedGameMode}</span>{" "}
            and invite friends.
          </p>
          <div className="flex gap-2">
            <button
              onClick={handleCreateRoom}
              disabled={isProcessing}
              className="h-12 flex-grow bg-accent hover:bg-accent-hover text-white font-bold py-3 px-4 rounded-md focus:outline-none focus:shadow-outline transform hover:scale-105 transition-transform duration-200 flex items-center justify-center disabled:opacity-70 disabled:cursor-not-allowed"
            >
              {isProcessing ? <Spinner className="w-6 h-6" /> : "Create Room"}
            </button>
            <button
              onClick={() => setIsInstructionsVisible(true)}
              className="flex-shrink-0 bg-surface-200 hover:bg-border text-text-secondary hover:text-text-primary font-bold p-3 rounded-md focus:outline-none focus:shadow-outline transform hover:scale-105 transition-transform duration-200"
              aria-label="How to Play"
            >
              <InfoIcon className="w-6 h-6" />
            </button>
          </div>
        </div>

        <div className="bg-surface-100 border border-border rounded-lg p-6 flex flex-col">
          <h2 className="text-2xl font-bold mb-4 flex items-center text-text-primary">
            <EnterIcon className="w-8 h-8 mr-2 text-primary" /> Join with
            Code
          </h2>
          <div className="flex gap-2 flex-grow items-center">
            <input
              type="text"
              value={joinCode}
              onChange={(e) => setJoinCode(e.target.value.toUpperCase())}
              onKeyDown={(e) =>
                e.key === "Enter" && handleJoinWithCode(joinCode)
              }
              className="flex-grow shadow appearance-none border border-border rounded-md w-full py-3 px-4 bg-surface-200 text-text-primary leading-tight focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all uppercase placeholder-text-secondary"
              placeholder="ROOM CODE"
              maxLength={6}
            />
            <button
              onClick={() => handleJoinWithCode(joinCode)}
              disabled={!joinCode || isProcessing}
              className="h-12 w-20 flex-shrink-0 bg-primary hover:bg-primary-hover text-white font-bold py-3 px-4 rounded-md focus:outline-none focus:shadow-outline transform hover:scale-105 transition-transform duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
            >
              {isProcessing ? <Spinner className="w-6 h-6" /> : "Join"}
            </button>
          </div>
          <p className={`text-error text-sm mt-2 h-5 transition-all duration-300 ${error ? 'animate-shake' : ''}`}>{error}</p>
        </div>
      </motion.div>

      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4 text-text-primary">Available Rooms</h2>
        <div className="space-y-3 max-h-60 overflow-y-auto pr-2">
          {isLoadingRooms ? (
            <div className="flex justify-center items-center py-8">
              <Spinner />
            </div>
          ) : availableRooms.length > 0 ? (
            availableRooms.map((room) => (
              <div
                key={room.id}
                className="bg-surface-100/80 border border-border rounded-lg p-4 flex items-center justify-between hover:bg-surface-200/60 transition-colors"
              >
                <div>
                  <p className="font-bold text-lg text-text-primary">{room.gameMode}</p>
                  <p className="text-sm text-text-secondary">
                    Room Code:{" "}
                    <span className="font-mono text-warning">
                      {room.id}
                    </span>
                  </p>
                </div>
                <div className="flex items-center gap-4">
                  <p className="text-text-secondary">
                    {room.playerCount} / {PLAYER_COLORS.length}
                  </p>
                  <button
                    onClick={() => handleJoinWithCode(room.id)}
                    disabled={isProcessing}
                    className="bg-primary hover:bg-primary-hover text-white font-bold py-2 px-4 rounded-md transition-colors disabled:opacity-50"
                  >
                    Join
                  </button>
                </div>
              </div>
            ))
          ) : (
            <div className="text-text-secondary text-center py-8 bg-surface-100/50 rounded-lg">
              <p>No public rooms available.</p>
              <p>Why not create one?</p>
            </div>
          )}
        </div>
      </div>
    </>
  );
};

export default LobbyPage;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/pages/LoginPage.tsx
<DOCUMENT>
import React, { useState, FormEvent, useEffect } from "react";
import { LogoIcon } from "@components/icons";
import { useGame } from "@contexts/GameContext";

const LoginPage: React.FC = () => {
  const { login } = useGame();
  const [username, setUsername] = useState("");

  useEffect(() => {
    const savedUsername = localStorage.getItem("pixel-arena-username");
    if (savedUsername) {
      setUsername(savedUsername);
    }
  }, []);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (username.trim()) {
      login(username.trim());
    }
  };

  return (
    <div className="w-full max-w-md mx-auto animate-in fade-in-50 duration-500">
      <div className="bg-surface-100/50 backdrop-blur-sm border border-border/50 rounded-2xl p-8 shadow-2xl shadow-primary/10">
        <div className="flex flex-col items-center mb-8">
          <div className="p-4 bg-surface-200 rounded-full mb-4 border border-border">
            <LogoIcon className="h-16 w-16 text-primary" />
          </div>
          <h1 className="text-5xl text-center font-bold tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-primary to-accent-secondary">
            PIXEL ARENA
          </h1>
          <p className="text-text-secondary mt-2 text-lg">Enter the arena.</p>
        </div>
        <form onSubmit={handleSubmit}>
          <div className="mb-6">
            <label
              htmlFor="username"
              className="block text-sm font-bold mb-2 text-text-primary sr-only"
            >
              Choose Your Username
            </label>
            <input
              type="text"
              id="username"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              autoFocus
              className="text-center text-lg shadow-inner appearance-none border-2 border-border rounded-lg w-full py-3 px-4 bg-surface-200/50 text-text-primary leading-tight focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary transition-all duration-300"
              placeholder="Enter your name"
              required
              maxLength={15}
            />
          </div>
          <button
            type="submit"
            className="w-full bg-gradient-to-r from-primary to-accent-secondary text-white font-bold text-lg py-3 px-4 rounded-lg focus:outline-none focus:ring-4 focus:ring-primary/50 transform hover:scale-105 transition-all duration-300 shadow-lg hover:shadow-primary/20 disabled:opacity-50 disabled:cursor-not-allowed"
            disabled={!username.trim()}
          >
            Play Now
          </button>
        </form>
      </div>
    </div>
  );
};

export default LoginPage;
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/services/socketEmitters.ts
<DOCUMENT>
import type {
  Room,
  Player,
  GameMode,
  MazeRaceDifficulty,
} from "../types/index";

// Forward declaration to avoid circular imports
interface SocketService {
  getSocket(): any;
}

export class SocketEmitters {
  private socketService: SocketService;

  constructor(socketService: SocketService) {
    this.socketService = socketService;
  }

  public createRoom(
    user: Omit<Player, "socketId">,
    gameMode: GameMode,
    callback: (room: Room) => void
  ) {
    this.socketService
      .getSocket()
      ?.emit("create-room", { user, gameMode }, callback);
  }

  public joinRoom(
    roomId: string,
    user: Omit<Player, "socketId">,
    callback: (res: { room: Room | null; error?: string }) => void
  ) {
    this.socketService
      .getSocket()
      ?.emit("join-room", { roomId, user }, callback);
  }

  public setGameMode(roomId: string, gameMode: GameMode) {
    this.socketService.getSocket()?.emit("set-game-mode", { roomId, gameMode });
  }

  public leaveRoom() {
    this.socketService.getSocket()?.emit("leave-room");
  }

  public getAvailableRooms() {
    this.socketService.getSocket()?.emit("get-available-rooms");
  }

  public updatePlayerPosition(
    roomId: string,
    playerId: string,
    newPos: { x: number; y: number }
  ) {
    this.socketService
      .getSocket()
      ?.emit("player-move", { roomId, playerId, newPos });
  }

  public activateAbility(roomId: string, playerId: string) {
    this.socketService
      .getSocket()
      ?.emit("player-ability", { roomId, playerId });
  }

  public submitHeistGuess(roomId: string, playerId: string, padId: string) {
    this.socketService
      .getSocket()
      ?.emit("player-heist-guess", { roomId, playerId, padId });
  }

  public submitGuess(roomId: string, playerId: string, guess: string) {
    this.socketService
      .getSocket()
      ?.emit("player-guess", { roomId, playerId, guess });
  }

  public startGame(roomId: string, playerId: string) {
    this.socketService.getSocket()?.emit("start-game", { roomId, playerId });
  }

  public setMazeRaceDifficulty(
    roomId: string,
    playerId: string,
    difficulty: MazeRaceDifficulty
  ) {
    this.socketService
      .getSocket()
      ?.emit("set-maze-difficulty", { roomId, playerId, difficulty });
  }
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/services/socketListeners.ts
<DOCUMENT>
import type { Room, Player, GameMode, GameState, MazeRaceDifficulty } from "../types/index";

// Forward declaration to avoid circular imports
interface SocketService {
  getSocket(): any;
}

export class SocketListeners {
  private socketService: SocketService;

  constructor(socketService: SocketService) {
    this.socketService = socketService;
  }

  public onAvailableRoomsUpdate(
    callback: (
      rooms: { id: string; gameMode: GameMode; playerCount: number }[]
    ) => void
  ) {
    this.socketService.getSocket()?.on("available-rooms-update", callback);
  }

  public offAvailableRoomsUpdate() {
    this.socketService.getSocket()?.off("available-rooms-update");
  }

  public onGameStarted(callback: (data: { room: Room }) => void) {
    this.socketService.getSocket()?.on("game-started", callback);
  }

  public onPlayerMoved(
    callback: (data: { playerId: string; x: number; y: number }) => void
  ) {
    this.socketService.getSocket()?.on("player-moved", callback);
  }

  public onPlayerTagged(
    callback: (data: { oldIt: string; newIt: string }) => void
  ) {
    this.socketService.getSocket()?.on("player-tagged", callback);
  }

  public onTileClaimed(
    callback: (data: {
      x: number;
      y: number;
      playerId: string;
      color: string;
    }) => void
  ) {
    this.socketService.getSocket()?.on("tile-claimed", callback);
  }

  public onPlayerInfected(callback: (data: { playerId: string }) => void) {
    this.socketService.getSocket()?.on("player-infected", callback);
  }

  public onTrapTriggered(
    callback: (data: { x: number; y: number; type: string }) => void
  ) {
    this.socketService.getSocket()?.on("trap-triggered", callback);
  }

  public onPlayerEffect(
    callback: (data: {
      playerId: string;
      type: "frozen" | "slow";
      expires: number;
    }) => void
  ) {
    this.socketService.getSocket()?.on("player-effect", callback);
  }

  public onPadGuessed(
    callback: (data: { padId: string; correct: boolean }) => void
  ) {
    this.socketService.getSocket()?.on("pad-guessed", callback);
  }

  public onPlayerOnPad(
    callback: (data: { playerId: string; padId: string }) => void
  ) {
    this.socketService.getSocket()?.on("player-on-pad", callback);
  }

  public offPlayerOnPad() {
    this.socketService.getSocket()?.off("player-on-pad");
  }

  public onPlayerOffPad(callback: (data: { playerId: string }) => void) {
    this.socketService.getSocket()?.on("player-off-pad", callback);
  }

  public offPlayerOffPad() {
    this.socketService.getSocket()?.off("player-off-pad");
  }

  public onTimerUpdate(callback: (data: { time: number }) => void) {
    this.socketService.getSocket()?.on("timer-update", callback);
  }

  public onScoresUpdate(
    callback: (data: { scores: { id: string; score: number }[] }) => void
  ) {
    this.socketService.getSocket()?.on("scores-update", callback);
  }

  public onPhaseChanged(
    callback: (data: { phase: GameState["phase"]; timer: number }) => void
  ) {
    this.socketService.getSocket()?.on("phase-changed", callback);
  }

  public onPlayerGuessed(
    callback: (data: { playerId: string; guess: string }) => void
  ) {
    this.socketService.getSocket()?.on("player-guessed", callback);
  }

  public onGameOver(
    callback: (data: {
      winner: Player | { name: string } | null;
      players: Player[];
    }) => void
  ) {
    this.socketService.getSocket()?.on("game-over", callback);
  }

  public onPlayerJoined(callback: (data: { player: Player }) => void) {
    this.socketService.getSocket()?.on("player-joined", callback);
  }

  public onPlayerLeft(callback: (data: { playerId: string }) => void) {
    this.socketService.getSocket()?.on("player-left", callback);
  }

  public onHostChanged(callback: (data: { newHostId: string }) => void) {
    this.socketService.getSocket()?.on("host-changed", callback);
  }

  public onGameModeChanged(
    callback: (data: { gameMode: GameMode; gameState: GameState }) => void
  ) {
    this.socketService.getSocket()?.on("game-mode-changed", callback);
  }

  public onAbilityActivated(
    callback: (data: {
      playerId: string;
      ability: "sprint" | "shield";
      expires: number;
    }) => void
  ) {
    this.socketService.getSocket()?.on("ability-activated", callback);
  }

  public onMazeDifficultyChanged(
    callback: (data: { difficulty: MazeRaceDifficulty; room: Room }) => void
  ) {
    this.socketService.getSocket()?.on("maze-difficulty-changed", callback);
  }

  public offMazeDifficultyChanged() {
    this.socketService.getSocket()?.off("maze-difficulty-changed");
  }
  
  public offAll() {
    this.socketService.getSocket()?.off();
  }
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/services/socketService.ts
<DOCUMENT>
import { io, Socket } from "socket.io-client";
import { SocketEmitters } from "@services/socketEmitters";
import { SocketListeners } from "@services/socketListeners";

class SocketService {
  private socket: Socket | null = null;
  private emitters: SocketEmitters;
  private listeners: SocketListeners;

  // Emitter methods
  public createRoom: typeof SocketEmitters.prototype.createRoom;
  public joinRoom: typeof SocketEmitters.prototype.joinRoom;
  public setGameMode: typeof SocketEmitters.prototype.setGameMode;
  public leaveRoom: typeof SocketEmitters.prototype.leaveRoom;
  public getAvailableRooms: typeof SocketEmitters.prototype.getAvailableRooms;
  public updatePlayerPosition: typeof SocketEmitters.prototype.updatePlayerPosition;
  public activateAbility: typeof SocketEmitters.prototype.activateAbility;
  public submitHeistGuess: typeof SocketEmitters.prototype.submitHeistGuess;
  public submitGuess: typeof SocketEmitters.prototype.submitGuess;
  public startGame: typeof SocketEmitters.prototype.startGame;
  public setMazeRaceDifficulty: typeof SocketEmitters.prototype.setMazeRaceDifficulty;

  // Listener methods
  public onAvailableRoomsUpdate: typeof SocketListeners.prototype.onAvailableRoomsUpdate;
  public offAvailableRoomsUpdate: typeof SocketListeners.prototype.offAvailableRoomsUpdate;
  public onGameStarted: typeof SocketListeners.prototype.onGameStarted;
  public onPlayerMoved: typeof SocketListeners.prototype.onPlayerMoved;
  public onPlayerTagged: typeof SocketListeners.prototype.onPlayerTagged;
  public onTileClaimed: typeof SocketListeners.prototype.onTileClaimed;
  public onPlayerInfected: typeof SocketListeners.prototype.onPlayerInfected;
  public onTrapTriggered: typeof SocketListeners.prototype.onTrapTriggered;
  public onPlayerEffect: typeof SocketListeners.prototype.onPlayerEffect;
  public onPadGuessed: typeof SocketListeners.prototype.onPadGuessed;
  public onPlayerOnPad: typeof SocketListeners.prototype.onPlayerOnPad;
  public onPlayerOffPad: typeof SocketListeners.prototype.onPlayerOffPad;
  public onTimerUpdate: typeof SocketListeners.prototype.onTimerUpdate;
  public onScoresUpdate: typeof SocketListeners.prototype.onScoresUpdate;
  public onPhaseChanged: typeof SocketListeners.prototype.onPhaseChanged;
  public onPlayerGuessed: typeof SocketListeners.prototype.onPlayerGuessed;
  public onGameOver: typeof SocketListeners.prototype.onGameOver;
  public onPlayerJoined: typeof SocketListeners.prototype.onPlayerJoined;
  public onPlayerLeft: typeof SocketListeners.prototype.onPlayerLeft;
  public onHostChanged: typeof SocketListeners.prototype.onHostChanged;
  public onGameModeChanged: typeof SocketListeners.prototype.onGameModeChanged;
  public onAbilityActivated: typeof SocketListeners.prototype.onAbilityActivated;
  public onMazeDifficultyChanged: typeof SocketListeners.prototype.onMazeDifficultyChanged;
  public offMazeDifficultyChanged: typeof SocketListeners.prototype.offMazeDifficultyChanged;
  public offPlayerOnPad: typeof SocketListeners.prototype.offPlayerOnPad;
  public offPlayerOffPad: typeof SocketListeners.prototype.offPlayerOffPad;
  public offAll: typeof SocketListeners.prototype.offAll;

  constructor() {
    this.emitters = new SocketEmitters(this);
    this.listeners = new SocketListeners(this);
    
    // Bind emitter methods
    this.createRoom = this.emitters.createRoom.bind(this.emitters);
    this.joinRoom = this.emitters.joinRoom.bind(this.emitters);
    this.setGameMode = this.emitters.setGameMode.bind(this.emitters);
    this.leaveRoom = this.emitters.leaveRoom.bind(this.emitters);
    this.getAvailableRooms = this.emitters.getAvailableRooms.bind(this.emitters);
    this.updatePlayerPosition = this.emitters.updatePlayerPosition.bind(this.emitters);
    this.activateAbility = this.emitters.activateAbility.bind(this.emitters);
    this.submitHeistGuess = this.emitters.submitHeistGuess.bind(this.emitters);
    this.submitGuess = this.emitters.submitGuess.bind(this.emitters);
    this.startGame = this.emitters.startGame.bind(this.emitters);
    this.setMazeRaceDifficulty = this.emitters.setMazeRaceDifficulty.bind(this.emitters);
    
    // Bind listener methods
    this.onAvailableRoomsUpdate = this.listeners.onAvailableRoomsUpdate.bind(this.listeners);
    this.offAvailableRoomsUpdate = this.listeners.offAvailableRoomsUpdate.bind(this.listeners);
    this.onGameStarted = this.listeners.onGameStarted.bind(this.listeners);
    this.onPlayerMoved = this.listeners.onPlayerMoved.bind(this.listeners);
    this.onPlayerTagged = this.listeners.onPlayerTagged.bind(this.listeners);
    this.onTileClaimed = this.listeners.onTileClaimed.bind(this.listeners);
    this.onPlayerInfected = this.listeners.onPlayerInfected.bind(this.listeners);
    this.onTrapTriggered = this.listeners.onTrapTriggered.bind(this.listeners);
    this.onPlayerEffect = this.listeners.onPlayerEffect.bind(this.listeners);
    this.onPadGuessed = this.listeners.onPadGuessed.bind(this.listeners);
    this.onPlayerOnPad = this.listeners.onPlayerOnPad.bind(this.listeners);
    this.onPlayerOffPad = this.listeners.onPlayerOffPad.bind(this.listeners);
    this.onTimerUpdate = this.listeners.onTimerUpdate.bind(this.listeners);
    this.onScoresUpdate = this.listeners.onScoresUpdate.bind(this.listeners);
    this.onPhaseChanged = this.listeners.onPhaseChanged.bind(this.listeners);
    this.onPlayerGuessed = this.listeners.onPlayerGuessed.bind(this.listeners);
    this.onGameOver = this.listeners.onGameOver.bind(this.listeners);
    this.onPlayerJoined = this.listeners.onPlayerJoined.bind(this.listeners);
    this.onPlayerLeft = this.listeners.onPlayerLeft.bind(this.listeners);
    this.onHostChanged = this.listeners.onHostChanged.bind(this.listeners);
    this.onGameModeChanged = this.listeners.onGameModeChanged.bind(this.listeners);
    this.onAbilityActivated = this.listeners.onAbilityActivated.bind(this.listeners);
    this.onMazeDifficultyChanged = this.listeners.onMazeDifficultyChanged.bind(this.listeners);
    this.offMazeDifficultyChanged = this.listeners.offMazeDifficultyChanged.bind(this.listeners);
    this.offPlayerOnPad = this.listeners.offPlayerOnPad.bind(this.listeners);
    this.offPlayerOffPad = this.listeners.offPlayerOffPad.bind(this.listeners);
    this.offAll = this.listeners.offAll.bind(this.listeners);
  }

  public getSocket(): Socket | null {
    return this.socket;
  }

  public connect() {
    if (!this.socket) {
      const backendUrl =
        import.meta.env.VITE_BACKEND_URL || "http://localhost:3000";
      this.socket = io(backendUrl, {
        transports: ["websocket"],
      });
    }
  }

  public disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }

}

export const socketService = new SocketService();
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/types/index.ts
<DOCUMENT>
export enum GameMode {
  TAG = "Tag",
  TERRITORY_CONTROL = "Territory Control",
  MAZE_RACE = "Maze Race",
  INFECTION_ARENA = "Infection Arena",
  TRAP_RUSH = "Trap Rush",
  SPY_AND_DECODE = "Spy & Decode",
  HEIST_PANIC = "Heist Panic",
}

export type TrapType = "slow" | "teleport" | "freeze";

export interface Trap {
  type: TrapType;
  revealed: boolean;
}

export interface PlayerEffect {
  type: "slow" | "frozen";
  expires: number;
}

export interface Player {
  id: string;
  name: string;
  x: number;
  y: number;
  color: string;
  score: number;
  socketId: string;
  isIt: boolean;
  isEliminated: boolean;
  // Infection Arena
  isInfected?: boolean;
  isShielded?: boolean;
  shieldUntil?: number;
  sprintUntil?: number;
  lastShieldTime?: number;
  lastSprintTime?: number;
  // Trap Rush & Heist Panic
  effects?: PlayerEffect[];
  lastMoveTime?: number;
  // Spy & Decode
  isSpy?: boolean;
  guess?: string | null;
}

export interface Tile {
  claimedBy: string | null;
  color: string | null;
}

export interface Spike {
  id: string;
  x: number;
  y: number;
}

export enum MazeRaceDifficulty {
  EASY = "easy",
  MEDIUM = "medium",
  HARD = "hard",
  EXPERT = "expert"
}

export interface Maze {
  grid: number[][]; // 0 for path, 1 for wall
  end: { x: number; y: number };
  difficulty?: MazeRaceDifficulty;
}

export type GameStatus = "waiting" | "playing" | "finished";

export interface CodePad {
  id: string;
  x: number;
  y: number;
}

export interface GameState {
  status: GameStatus;
  timer: number;
  winner: Player | { name: string } | null;
  tiles?: Tile[][];
  maze?: Maze;
  // Trap Rush
  trapMap?: (Trap | null)[][];
  finishLine?: number;
  // Spy & Decode
  phase?: "signaling" | "guessing" | "reveal";
  codes?: { id: string; value: string }[];
  correctCodeId?: string;
  playerGuesses?: Record<string, string>;
  // Heist Panic
  codePads?: CodePad[];
  correctPadId?: string;
}

export interface Room {
  id: string;
  hostId: string;
  gameMode: GameMode;
  players: Player[];
  gameState: GameState;
  // Maze Race specific settings
  mazeRaceSettings?: {
    difficulty: MazeRaceDifficulty;
  };
}

export interface SendReactionPayload {
  emoji: string;
}

export interface ReceiveReactionPayload {
  emoji: string;
}
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/utils/clipboard.ts
<DOCUMENT>
import { useState, useCallback } from "react";

export const useClipboard = (text: string) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = useCallback(() => {
    navigator.clipboard
      .writeText(text)
      .then(() => {
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      })
      .catch((err) => console.error("Failed to copy text: ", err));
  }, [text]);

  return { copied, handleCopy };
};
</DOCUMENT>

G:/Ahad/pixel-arena/client/src/utils/ReactionManager.ts
<DOCUMENT>
import { socketService } from "@services/socketService";
import type { SendReactionPayload, ReceiveReactionPayload } from "../types";

type ReactionCallback = (emoji: string) => void;

class ReactionManager {
  private static callback: ReactionCallback | null = null;

  static send(emoji: string) {
    const payload: SendReactionPayload = { emoji };
    socketService.getSocket()?.emit("send-reaction", payload);
  }

  static onReceive(callback: ReactionCallback) {
    this.offReceive(); // ensure no duplicates
    this.callback = callback;
    socketService.getSocket()?.on("receive-reaction", (data: ReceiveReactionPayload) => {
      this.callback?.(data.emoji);
    });
  }

  static offReceive() {
    socketService.getSocket()?.off("receive-reaction");
    this.callback = null;
  }
}

export default ReactionManager;
</DOCUMENT>

